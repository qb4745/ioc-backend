# Prompt: Crear Nuevo Blueprint y Tareas de Backlog (v3)

### Guía Rápida para el Humano
1.  **Edita la sección `## Template de Ejecución`** con los detalles de la tarea.
2.  **Copia el contenido completo de este archivo** (`Ctrl+A`, `Ctrl+C`).
3.  **Pega el contenido en Gemini CLI** y presiona `Enter`.

---

## Template de Ejecución (EDITAR ESTA SECCIÓN)

**ID_DE_LA_HISTORIA**: "IOC-001"

**DESCRIPCION_DE_LA_FUNCIONALIDAD**: "Optimización y Robustecimiento del Pipeline de Ingesta de Datos ETL"

**TAREA_ESPECIFICA_EN_KEBAB_CASE**: "etl-pipeline-batch-and-validation-refactor"

**CONTEXTO_ADICIONAL**: "Refactorizar el ParserService actual para que procese archivos grandes de forma eficiente (sin agotar la memoria) y añadir una capa de validación explícita para detectar datos corruptos antes de llegar a la base de datos."

**STACK_PRINCIPAL**: "Spring Boot + JPA + Jakarta Bean Validation"

**ASIGNADO_PRINCIPAL**: "Boris"  <!-- Opciones: "Boris", "Jaime" -->

---

## Instrucciones para la IA (NO EDITAR ESTA SECCIÓN)

Tu rol es el de un Principal Solutions Architect y Asistente de Planificación Técnica.

Utilizando las variables definidas en la sección `## Template de Ejecución`, realiza las siguientes acciones en orden estricto:

1.  **Analiza el Contexto:** Revisa nuestra conversación reciente, el plan, el código generado y las pruebas realizadas para la implementación de la historia `{{ID_DE_LA_HISTORIA}}`. Esta es tu fuente de verdad.

2.  **Genera el Contenido del Blueprint:** Utilizando el contexto analizado, genera el contenido completo de un blueprint de implementación. Sigue rigurosamente la plantilla de Markdown proporcionada más abajo.

3.  **Deriva las Tareas Técnicas del Blueprint:** Una vez generado el contenido del blueprint, **debes** analizarlo y extraer una lista de tareas técnicas accionables para el backlog del sprint.
    *   Las tareas deben derivarse directamente de los pasos en las secciones `3. Implementación Paso a Paso` y `4. Testing y Validación`.
    *   Cada tarea debe seguir **exactamente** el siguiente formato: `[Prefijo]-TASK-[Número de Tarea] [ID de Historia] [Asignado] [Descripción de la Tarea]`
        *   **[Prefijo]:** Usa `BE` para Backend, `FE` para Frontend, `DB` para Base de Datos/JPA, `QA` para Testing.
        *   **[Número de Tarea]:** Usa un placeholder como `XX` (ej. `BE-TASK-XX`), ya que el número final lo asignará el sistema de backlog.
        *   **[ID de Historia]:** Usa la variable `{{ID_DE_LA_HISTORIA}}`.
        *   **[Asignado]:** Usa la variable `{{ASIGNADO_PRINCIPAL}}`.
        *   **[Descripción de la Tarea]:** Debe ser una descripción clara y concisa de un solo paso del blueprint.

4.  **Presenta los Resultados y Crea el Archivo:**
    *   Primero, muestra en la consola la lista de tareas técnicas generadas.
    *   Luego, define el nombre del archivo del blueprint usando el formato `[ID_Historia]-[tarea-especifica].md`.
    *   Finalmente, crea el nuevo archivo del blueprint en la ruta `@.gemini/blueprints/[nombre-del-archivo]` con el contenido generado en el paso 2 y confirma la creación exitosa.

### Plantilla del Blueprint (A ser usada en el Paso 2)

```markdown
# Blueprint: {{DESCRIPCION_DE_LA_FUNCIONALIDAD}}

Esta guía detalla el proceso paso a paso para implementar la funcionalidad.

## 1. Objetivo y Alcance
*   **Objetivo:** <!-- Describir qué se logra con este blueprint. -->
*   **Stack Tecnológico Involucrado:** <!-- Listar tecnologías clave. -->
*   **Contexto Adicional:** {{CONTEXTO_ADICIONAL}}

## 2. Prerrequisitos
*   **Dependencias:** <!-- Listar dependencias de npm o pom.xml. -->
*   **Configuración:** <!-- Mencionar variables de entorno o configuración. -->
*   **Stack Principal:** {{STACK_PRINCIPAL}}

## 3. Implementación Paso a Paso

### 3.1 Backend (Spring Boot)
*   **Paso 1: <!-- Nombre del Paso -->**
    *   **Archivo:** <!-- Ruta al archivo. -->
    *   **Objetivo:** <!-- Qué logra este paso. -->
    *   **Código:**
        ```java
        // Insertar aquí el código Java relevante.
        ```
    *   **Validación:** <!-- Cómo verificar que funciona. -->

### 3.2 Frontend (React)
*   **Paso 1: <!-- Nombre del Paso -->**
    *   **Archivo:** <!-- Ruta al archivo. -->
    *   **Objetivo:** <!-- Qué logra este paso. -->
    *   **Código:**
        ```tsx
        // Insertar aquí el código TSX relevante.
        ```
    *   **Validación:** <!-- Cómo verificar que funciona. -->

### 3.3 Configuración y Dependencias
*   **Archivo:** `pom.xml`, `package.json` o `application.yml`
*   **Código:**
    ```xml
    <!-- Dependencias necesarias -->
    ```

### 3.4 Database/JPA (si aplica)
*   **Migraciones:** <!-- Scripts SQL si se necesitan -->
*   **Entidades:** <!-- Cambios en entidades JPA -->

## 4. Testing y Validación
### 4.1 Tests Unitarios
*   **Archivo:** <!-- Ruta al test -->
*   **Casos de Prueba:**
    ```java
    // Tests específicos
    ```
### 4.2 Tests de Integración
*   <!-- Descripción de tests end-to-end -->

## 5. Flujo de Verificación
*   <!-- Describir los pasos para la verificación manual. -->

## 6. Consideraciones de Performance
*   **Memoria:** <!-- Impacto en uso de memoria -->
*   **Escalabilidad:** <!-- Límites y optimizaciones -->
*   **Monitoreo:** <!-- Métricas clave a observar -->

## 7. Consideraciones de Seguridad y Buenas Practicas
*   <!-- Añadir notas importantes. -->

## 8. Troubleshooting Común
*   **Error:** <!-- Descripción del error -->
    *   **Causa:** <!-- Por qué ocurre -->
    *   **Solución:** <!-- Cómo resolverlo -->