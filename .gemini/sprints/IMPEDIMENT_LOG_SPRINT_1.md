# Registro de Impedimentos del Sprint 1 (v1.3)

Este documento es un artefacto vivo utilizado para rastrear, gestionar y aprender de todos los obstáculos que afectan el progreso del Sprint 1.

---

## Proceso de Gestión de Impedimentos
1.  **Identificación:** Cualquier miembro del equipo añade un nuevo impedimento a la lista.
2.  **Análisis:** En la Daily Scrum, se define el plan de acción, el responsable, la causa raíz y la acción preventiva.
3.  **Seguimiento:** El estado se actualiza diariamente hasta su resolución.

---

## Registro de Impedimentos

| ID | Impedimento | Responsable | Plan de Acción | Causa Raíz | Acción Preventiva | Estado |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **IMP-001** | **Flujo de usuario incompleto (Error 404):** La página `/update-password` no existía. | **Jaime** | Implementar la vista y ruta faltantes según el blueprint. | **Planificación Incompleta:** El blueprint inicial no contempló la página de destino del enlace de reseteo. | **Mejora de Blueprints:** Actualizar todos los futuros blueprints para incluir explícitamente todas las vistas y rutas implicadas en un flujo. | ✅ **Resuelto** |
| **IMP-002** | **Deuda técnica por tipado laxo:** El uso de `any` y la falta de tipos específicos generaron advertencias de calidad. | **Jaime** | Refactorizar los componentes afectados para usar tipos estrictos e interfaces. | **Desarrollo Acelerado:** Se priorizó la funcionalidad sobre la calidad de tipos en la implementación inicial. | **Definición de Hecho (DoD):** Añadir un criterio al DoD que exija "cero advertencias de `any` explícito" en el código nuevo. | ✅ **Resuelto** |
| **IMP-03** | **UX Inconsistente en notificaciones:** El uso de `alert()` nativo rompía con el sistema de diseño. | **Jaime** | Instalar `react-hot-toast` y refactorizar los formularios para usar notificaciones emergentes. | **Falta de un Sistema de Notificaciones:** El proyecto no contaba con una solución estandarizada para notificaciones. | **Decisión de Arquitectura:** Adoptar `react-hot-toast` como la librería oficial para todas las notificaciones emergentes del proyecto. | ✅ **Resuelto** |
| **IMP-004** | **Cierre de sesión inseguro:** El logout desde el menú de usuario no invalidaba la sesión correctamente. | **Jaime** | Implementar la lógica `handleSignOut` en `UserDropdown.tsx` usando `window.location.href` para forzar la recarga. | **Lógica Duplicada e Incompleta:** La funcionalidad de logout estaba implementada de forma incorrecta en un componente y correcta en otro. | **Centralizar Lógica Crítica:** Refactorizar la lógica de autenticación a hooks (`useAuth`) para evitar implementaciones inconsistentes. | ✅ **Resuelto** |
| **IMP-005** | **UI Rota en Tabla de Historial:** La tabla de ingesta de datos se mostraba desalineada. | **Boris** | Refactorizar la tabla para usar patrones de la plantilla (padding en celdas y contenedor con overflow) en lugar de anchos fijos. | **Desviación del Sistema de Diseño:** Se aplicó una solución CSS (`table-fixed`) que no era consistente con el resto de la aplicación. | **Revisión de Patrones Existentes:** Antes de crear un componente complejo, verificar si la plantilla ya ofrece un patrón similar para reutilizar. | ✅ **Resuelto** |
| **IMP-006** | **Feedback de UI incompleto:** Faltaban indicadores visuales para la validación de archivos y el estado de carga. | **Boris** | 1. Crear un `Spinner` reutilizable. 2. Modificar el `Dropzone` para mostrar el `Spinner` y mensajes de error contextuales. | **Omisión en la Implementación:** Los estados se manejaron lógicamente (deshabilitando botones) pero no visualmente. | **Mejora del DoD:** Añadir al DoD: "Todos los procesos asíncronos deben tener un indicador de carga visual. Todos los formularios deben mostrar errores de validación contextuales." | ✅ **Resuelto** |
| **IMP-007** | **Fallo masivo de tests (`ApplicationContext`):** La suite de tests no arrancaba debido a fallos en la carga del contexto de Spring. | **Jaime** | 1. Crear un perfil de test (`application-test.properties`). 2. Configurar una BD H2 en memoria para aislar los tests. 3. Excluir la `SecurityConfig` de los tests para evitar dependencias de variables de entorno. | **Configuración de Entorno Faltante:** El proyecto carecía de una configuración de base de datos específica para el entorno de prueba, causando conflictos con la configuración de producción. | **Estandarizar Configuración de Tests:** Definir como práctica estándar que todo nuevo proyecto Spring Boot debe incluir un perfil de test con una base de datos en memoria desde el inicio. | ✅ **Resuelto** |
| **IMP-008** | **Fallo de persistencia con Clave Compuesta:** La inserción en `fact_production` fallaba con `violates not-null constraint` en la columna `id`. | **Jaime** | Refactorizar la entidad `FactProduction` para usar una clave primaria simple (`@Id @GeneratedValue`) en lugar de una compuesta (`@EmbeddedId`). | **Anti-patrón de Persistencia:** El uso de `BIGSERIAL` en una parte de una clave primaria compuesta es un anti-patrón que no es manejado limpiamente por JPA/Hibernate. | **Decisión de Arquitectura:** Establecer como regla de diseño que todas las nuevas tablas deben usar claves primarias simples (sustitutas) y auto-incrementales. | ✅ **Resuelto** |
| **IMP-009** | **Rendimiento de ETL inaceptable:** El procesamiento de un archivo de 17,000 filas tardaba más de 4 minutos. | **Jaime** | 1. Refactorizar el `ParserService` para usar un caché en memoria de las dimensiones. 2. Cambiar la estrategia de generación de ID a `SEQUENCE` y configurar el batching de JDBC en `application.properties`. | **Cuello de Botella en la Base de Datos:** El parser realizaba miles de llamadas `SELECT` individuales a la BD dentro de un bucle, y la estrategia `IDENTITY` impedía el batching real de los `INSERT`. | **Principio de Diseño de ETL:** Establecer como principio que toda lógica de parseo masivo debe precargar las dimensiones en un caché y toda inserción masiva debe usar batching de JDBC. | ✅ **Resuelto** |
| **IMP-010** | **Rediseño de la Planificación de Sprints:** El alcance y la duración de los sprints originales resultaron ser inadecuados. | **Equipo** | Re-analizar las historias de usuario, re-estimar el esfuerzo y consolidar el plan de 4 a 3 sprints con un alcance redefinido para cada uno. | **Estimación Inicial Imprecisa:** La complejidad y las dependencias de las historias de usuario no se evaluaron con suficiente profundidad durante la planificación inicial. | **Mejora del Sprint Planning:** Implementar sesiones de refinamiento del backlog (`Backlog Refinement`) a mitad de cada sprint para re-evaluar y ajustar las estimaciones del siguiente sprint con información más actualizada. | ✅ **Resuelto** |
| **IMP-011** | **Conexión rechazada (`ECONNREFUSED`) entre Frontend y Backend:** El proxy de Vite no lograba conectar con el backend a pesar de que este estaba en ejecución. | **Jaime** | Modificar el `target` del proxy en `vite.config.ts` de `localhost` a `127.0.0.1` para resolver un conflicto de resolución de red. | **Inconsistencia de Red Local:** El entorno de desarrollo resolvía `localhost` y `127.0.0.1` de manera diferente para distintas aplicaciones. | **Estandarizar Proxies:** Definir como práctica estándar el uso de `127.0.0.1` en las configuraciones de proxy de Vite para garantizar una comunicación de red consistente. | ✅ **Resuelto** |
| **IMP-012** | **Error `400 Bad Request` de Metabase:** El `iframe` no cargaba el dashboard, y la consola de Metabase mostraba un error "No encontrado". | **Jaime** | Acceder a la configuración del dashboard en la UI de Metabase y hacer clic en "Publicar" para habilitar su embedding. | **Desconocimiento de Requisito:** Se desconocía que un dashboard debe ser explícitamente "publicado" en Metabase para poder ser embebido. | **Mejorar Documentación:** Actualizar la guía interna de embedding de Metabase con un checklist que incluya la "publicación" como un paso obligatorio. | ✅ **Resuelto** |
| **IMP-013** | **Bucle de Renderizado Infinito:** La página de dashboards generaba peticiones masivas al backend, activando el `RateLimiter`. | **Jaime** | Envolver las funciones de callback (`handleDashboardError`, `handleDashboardLoad`) en `DashboardsPage.tsx` con el hook `useCallback`. | **Dependencia Inestable en `useEffect`:** Se pasaban funciones re-creadas en cada render como props a un componente hijo que las usaba en su array de dependencias. | **Guía de Estilo para Hooks:** Establecer como regla: "Toda función pasada como prop a un componente que la use en un `useEffect` DEBE estar memoizada con `useCallback`". | ✅ **Resuelto** |
| **IMP-014** | **Violación de Política de Seguridad de Contenido (CSP):** El navegador bloqueaba los estilos en línea (`style="..."`). | **Jaime** | Refactorizar los componentes para eliminar todos los estilos en línea, pasando las dimensiones a través de clases de Tailwind CSS. | **Uso de Estilos en Línea:** Se utilizó el atributo `style` para definir alturas, lo cual es incompatible con una CSP estricta. | **Mejora del DoD:** Añadir al DoD: "El código no debe introducir nuevos usos de estilos en línea. Se deben preferir siempre las clases de CSS/Tailwind". | ✅ **Resuelto** |
| **IMP-015** | **Fallo de Conexión a BD en Arranque Local:** La aplicación no podía conectar a la base de datos (`FATAL: password authentication failed`) debido a que el perfil de Spring 'dev' no se activaba consistentemente. | **Jaime** | 1. Diagnosticar el problema de activación de perfiles usando un puerto de servidor diferente. 2. Identificar que `-Dspring.profiles.active=dev` no era una solución robusta. 3. Establecer `spring.profiles.active=dev` directamente en `application.properties` como perfil por defecto. | **Configuración de Entorno Frágil:** La activación de perfiles de Spring dependía de argumentos de línea de comandos (`-D...`) que no se propagaban de manera fiable al ejecutar la aplicación a través del Maven Wrapper (`./mvnw`). | **Estandarizar Arranque Local:** Definir como práctica estándar la activación del perfil de desarrollo por defecto directamente en `application.properties` para garantizar un arranque consistente y simplificado. | ✅ **Resuelto** |
| | | | | | | |
