# Technical Design (TD-001A) ‚Äì Explicaci√≥n de Dashboard con Gemini (Alternativa A - MVP)

> ID Feature: FP-001A  
> Estado Feature Plan: READY FOR IMPLEMENTATION (v0.4 REFINED)  
> Documento: TD-001A-dashboard-ai-explanation-A  
> Autor (TD): Arquitectura / IA Asistida  
> Fecha: 2025-11-11  
> Versi√≥n TD: 1.0-DRAFT  
> Esquema versionado: Semver (1.x = iteraciones draft, 2.0 = aprobado)  
> Alcance: MVP Bot√≥n Global Explicar Dashboard (sin interacci√≥n dentro de iframe)

---

## 0. ‚ö†Ô∏è PRE-REQUISITOS BLOQUEANTES

Antes de iniciar la implementaci√≥n, **DEBE confirmarse** lo siguiente (son bloqueantes):

- [ ] **Actualizaci√≥n de datos** (CR√çTICO para la estrategia de cache/TTL):
      - ¬øLos datos se actualizan en TIEMPO REAL o en BATCH diario?
      - Si TIEMPO REAL ‚Üí cache corto (30 min) y consideraciones de concurrencia.
      - Si BATCH DIARIO ‚Üí cache hist√≥rico (24h) para periodos que no incluyan hoy.
      - Acciones: confirmar con Data Team y documentar la frecuencia de refresh.

- [ ] **Presupuesto para paid tier de Gemini confirmado**:
      - Free tier: 15 RPM (requests per minute) ‚Üí soporta ~3 usuarios concurrentes.
      - Si se esperan >3 usuarios simult√°neos en producci√≥n, planificar migraci√≥n paid-tier.
      - Presupuesto estimado: $2-5/mes seg√∫n uso inicial.

- [ ] **Usuarios simult√°neos esperados (peak)**:
      - <= 3 ‚Üí Free tier viable
      - 4-10 ‚Üí Paid tier recomendado
      - >10 ‚Üí Dise√±ar cola/worker + paid tier

- [x] **GEMINI_API_KEY obtenida** ‚úÖ
- [x] **Componente frontend identificado** ‚úÖ
- [x] **Decisi√≥n de persistencia tomada (NamedParameterJdbcTemplate para agregados)** ‚úÖ

üî¥ **Si falta alguna de las tres entradas bloqueantes (actualizaci√≥n de datos / presupuesto / concurrencia esperada) ‚Üí NO empezar** (riesgo de bloquearse mid-work y generar sobrecostos).

---

## üìë TABLA DE CONTENIDOS

**Arquitectura y Contexto**
- [1. Resumen Ejecutivo](#1-resumen-ejecutivo)
- [2. Alcance y No Alcance](#2-alcance-y-no-alcance)
- [3. Drivers & Justificaci√≥n T√©cnica](#3-drivers--justificaci√≥n-t√©cnica)
- [4. Arquitectura T√©cnica](#4-arquitectura-t√©cnica)
- [5. Flujo de Datos Detallado](#5-flujo-de-datos-detallado-happy-path)

**Datos y Persistencia**
- [6. Modelo de Datos / Persistencia](#6-modelo-de-datos--persistencia)
- [7. Capa de Acceso a Datos Anal√≠ticos](#7-capa-de-acceso-a-datos-anal√≠ticos)
- [7.1. Queries SQL Completas](#71-queries-sql-completas)

**Contratos y Validaciones**
- [8. API Contract](#8-api-contract)
- [9. Validaciones y Reglas](#9-validaciones-y-reglas)
- [10. Caching Strategy](#10-caching-strategy)

**Integraciones y C√≥digo**
- [11. Gemini Integration](#11-gemini-integration)
- [11.5. C√≥digo de Ejemplo](#115-c√≥digo-de-ejemplo-snippets-gu√≠a)

**Seguridad y Performance**
- [12. Seguridad & Compliance](#12-seguridad--compliance)
- [13. Performance & Latency Budget](#13-performance--latency-budget)
- [14. Escalabilidad & Costos](#14-escalabilidad--costos)
- [15. Observabilidad](#15-observabilidad)

**Testing y Plan de Trabajo**
- [16. Testing Plan](#16-testing-plan)
- [17. Plan de Implementaci√≥n](#17-plan-de-implementaci√≥n-tareas-secuenciadas)
- [18. Prompt Construction](#18-prompt-construction--detalle-t√©cnico)

**Edge Cases y Riesgos**
- [19. Edge Cases & Manejo de Errores](#19-edge-cases--manejo-de-errores)
- [20. Riesgos & Mitigaciones](#20-riesgos--mitigaciones)
- [21. Extensibilidad Futura](#21-extensibilidad-futura)

**Checklists y Configuraci√≥n**
- [22. Checklist Implementaci√≥n](#22-checklist-implementaci√≥n-backend)
- [23. Propiedades & Configuraci√≥n](#23-propiedades--configuraci√≥n-propuestas)
- [23.5. Dependencias Maven](#235-dependencias-maven-requeridas)

**Cierre**
- [24. M√©tricas de √âxito](#24-m√©tricas-de-√©xito-del-fp-adaptadas-a-td)
- [25. Referencias](#25-referencias)
- [26. Aprobaciones Requeridas](#26-aprobaciones-requeridas)
- [27. Estado Actual](#27-estado-actual)
- [28. Pr√≥ximos Pasos Inmediatos](#28-pr√≥ximos-pasos-inmediatos)

---
## 1. Resumen Ejecutivo
Implementar un endpoint backend + componente frontend que genere una explicaci√≥n ejecutiva, puntos clave, insights y alertas sobre un dashboard de producci√≥n (Metabase) usando Gemini. El backend sintetiza datos agregados v√≠a SQL sobre `fact_production` y dimensiones asociadas, construye un prompt estructurado (system + contexto negocio + agregados), invoca Gemini y retorna respuesta JSON parseada y cacheada (TTL din√°mico). Se aplica RBAC, rate limiting, auditor√≠a y estrategia de costos para mantener uso dentro free tier inicialmente.

---
## 2. Alcance y No Alcance

### Alcance (MVP)
- 1 endpoint POST `/api/v1/ai/explain-dashboard` (JSON in/out) con validaciones.
- Capa de agregaci√≥n anal√≠tica mediante `NamedParameterJdbcTemplate` (queries del FP).
- Caching in-memory (Caffeine) con TTL din√°mico hist√≥rico vs periodo activo.
- Invocaci√≥n a Gemini (model configurable) con timeout (90s) + retries controlados.
- Sanitizaci√≥n / anonimizaci√≥n de campos PII seg√∫n `send_pii_to_gemini`.
- Auditor√≠a (logs estructurados) de cada request (user, dashboard, latencias, tokens, cacheHit).
- M√©tricas Micrometer: counters, timers, gauges relevantes.
- Componente React bot√≥n + modal explicativo con fases de loading.

### Fuera de Alcance (MVP)
- Persistencia de explicaciones en BD (solo cache vol√°til).
- Lectura contextual interactiva por gr√°fico espec√≠fico dentro iframe.
- Integraci√≥n Metabase API para metadatos / queries din√°micas.
- Sistema de colas / job async para generaci√≥n.
- Modelos alternativos de IA (OpenAI, Claude) ‚Äì se dise√±a extensibilidad.
- Internacionalizaci√≥n (solo espa√±ol).

---
## 3. Drivers & Justificaci√≥n T√©cnica
| Driver | Soluci√≥n | Raz√≥n |
|--------|----------|-------|
| Evitar Same-Origin con iframe | Bot√≥n fuera del iframe | Reduce complejidad t√©cnica y riesgos de seguridad. |
| Minimizar costo IA | Cache + TTL din√°mico + rate limiting | Mantener free tier viable. |
| Control total sobre agregaciones | JDBC con NamedParameterJdbcTemplate | Queries agregadas optimizadas, evita sobrecarga JPA. |
| Respuesta fiable | JSON estricto parseado | Evita errores de markdown y parsing heur√≠stico. |
| Escalabilidad futura | Dise√±o de capas y abstracciones | Permite introducir persistencia y colas en siguientes iteraciones. |

---
## 4. Arquitectura T√©cnica

### Componentes Nuevos
- `AiExplanationController` (REST)
- `DashboardExplanationService` (orquestaci√≥n)
- `GeminiApiClient` (gateway a IA)
- `DashboardAnalyticsRepository` (consultas anal√≠ticas)
- DTOs: `DashboardExplanationRequest`, `DashboardExplanationResponse`, `GeminiJsonResponse`, `TotalsDto`, `TopOperarioDto`, `TurnoDistributionDto`, `TopMachineDto`, `DailyTrendPoint`.
- Capa cache (Caffeine) con key compuesta.
- Auditor√≠a interna (a futuro: `AiExplanationAuditRepository`).

### Diagrama ASCII (Alto Nivel)
```
+------------------+          POST /api/v1/ai/explain-dashboard
|  Frontend SPA    |  ---------------------------------------------->
|  React Button    |   JSON {dashboardId, fechaInicio, fechaFin,...}
+---------+--------+                                             |
          |                                                      |
          | 1. Solicitud                                          v
          |                                              +--------------------+
          |                                              | AiExplanationCtrl  |
          |                                              +---------+----------+
          |                                                        |
          |                                                2 Validar / RateLimit
          |                                                        |
          |                                                3 Cache Lookup (Caffeine)
          |                                                        |
          |                                     +------------------v-------------------+
          |                                     | DashboardExplanationService          |
          |                                     +---------+-----------+---------------+
          |                                               |queries    | Gemini call
          |                                    4 Aggregar |           | 5 Prompt Build
          |                                               v           v
          |                                     +----------------+  +----------------+
          |                                     | Analytics Repo |  | GeminiApiClient|
          |                                     +--------+-------+  +-------+--------+
          |                                              |SQL             |HTTP
          |                                              v                v
          |                                     +---------------+   +------------+
          |                                     | PostgreSQL    |   | Gemini API |
          |                                     +---------------+   +------------+
          |                                                        ^
          |                                           6 Respuesta JSON parseada
          |                                                        |
          |                                                7 Cache Store
          |                                                        |
          |<--------------------------------------------------------+
          |          8 Render modal con JSON
```

---
## 5. Flujo de Datos Detallado (Happy Path)
1. Usuario hace clic en "‚ú® Explicar Dashboard".
2. Frontend abre modal (permite confirmar periodo) y env√≠a POST.
3. Backend autentica JWT, valida rol y acceso al dashboard.
4. Rate limiter verifica cuota (Bucket4j/Resilience4j). Si excedido ‚Üí 429.
5. Cache: key = `dashboard:{id}:fi:{fechaInicio}:ff:{fechaFin}:filters:{hash}`.
6. Miss ‚Üí ejecutar queries (Totals, TopOperarios, Turnos, M√°quinas, Tendencia).
7. Construir prompt: System (archivo), Contexto YAML, Datos agregados formateados, Instrucciones finales.
8. GeminiApiClient env√≠a request (timeout global 90s, connect 5s, read 85s). Retries en 503/timeout (m√°x 2 con backoff exponencial).
9. Recibe respuesta (ideal: JSON puro). Parser extrae bracket principal, deserializa `GeminiJsonResponse` ‚Üí valida.
10. Crea `DashboardExplanationResponse` con metadata + token estimation + cache TTL.
11. Guarda en cache con TTL calculado.
12. Auditor√≠a: log estructurado con duraci√≥n fases.
13. Response 200 ‚Üí Frontend actualiza modal y muestra secciones.

---
## 6. Modelo de Datos / Persistencia
- No se crean nuevas tablas en MVP (cache in-memory). 
- Consideraci√≥n futura: Tabla `ai_explanation_audit` para historizar uso y costos.

### Tabla futura (propuesta opcional)
```sql
CREATE TABLE ai_explanation_audit (
  id BIGSERIAL PRIMARY KEY,
  user_id VARCHAR(64) NOT NULL,
  dashboard_id INT NOT NULL,
  fecha_inicio DATE NOT NULL,
  fecha_fin DATE NOT NULL,
  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  from_cache BOOLEAN NOT NULL,
  tokens_usados INT NOT NULL,
  latency_ms INT NOT NULL,
  cache_ttl_seconds INT NOT NULL,
  status VARCHAR(20) NOT NULL -- SUCCESS|TIMEOUT|ERROR|RATE_LIMIT
);
CREATE INDEX idx_ai_exp_audit_user ON ai_explanation_audit(user_id);
CREATE INDEX idx_ai_exp_audit_dashboard ON ai_explanation_audit(dashboard_id);
```
(Implementar cuando se requiera trazabilidad costo o facturaci√≥n interna.)

---
## 7. Capa de Acceso a Datos Anal√≠ticos
### Repositorio: `DashboardAnalyticsRepository`
M√©todos:
- `TotalsDto fetchTotals(LocalDate fi, LocalDate ff)`
- `List<TopOperarioDto> fetchTopOperarios(fi, ff)`
- `List<TurnoDistributionDto> fetchDistribucionTurno(fi, ff)`
- `List<TopMachineDto> fetchTopMaquinas(fi, ff)`
- `List<DailyTrendPoint> fetchTendenciaDiaria(fi, ff)`

Uso `NamedParameterJdbcTemplate` con mapeo manual a records/DTO.
Validar: rango ‚â§ `max_query_range_months` (12). Si excede ‚Üí 400.

Optimizaci√≥n: a√±adir √≠ndices si falta performance en `fact_production` (ya existe por fecha). Evaluar √≠ndice compuesto `(fecha_contabilizacion, turno)` si filtros por turno frecuentes.

---
## 7.1. Queries SQL Completas

Las queries utilizadas por `DashboardAnalyticsRepository` se encuentran agrupadas en un archivo SQL dedicado. Implementadores deben usar estas queries tal cual para mantener sincron√≠a con el Feature Plan.

Archivo con las 5 queries (Totales, Top operarios, Distribuci√≥n por turno, Top m√°quinas, Tendencia diaria):

`.gemini/sprints/feature-plans/FP-001A-aggregations.sql`

> Nota: Usa `NamedParameterJdbcTemplate` y pasa `:fechaInicio` y `:fechaFin` como par√°metros nombrados. No modifiques las queries sin acordarlo con Data Team.

---
## 8. API Contract
### Endpoint
`POST /api/v1/ai/explain-dashboard`

Request JSON:
```json
{
  "dashboardId": 5,
  "fechaInicio": "2025-06-01",
  "fechaFin": "2025-06-30",
  "filtros": {"turno": "D√≠a"}
}
```

Response 200:
```json
{
  "resumenEjecutivo": "...",
  "keyPoints": ["..."],
  "insightsAccionables": ["..."],
  "alertas": ["..."],
  "metadata": {
    "dashboardId": 5,
    "titulo": "Producci√≥n por Operario - Mensual",
    "fechaInicio": "2025-06-01",
    "fechaFin": "2025-06-30",
    "filtrosAplicados": {"turno": "D√≠a"}
  },
  "generadoAt": "2025-11-11T22:00:00Z",
  "fromCache": false,
  "tokensUsados": 1245,
  "cacheTTLSeconds": 1800
}
```

Errores (resumen):
| Status | error | Ejemplo mensaje |
|--------|-------|-----------------|
| 400 | VALIDATION_ERROR | fechaFin debe ser >= fechaInicio |
| 401 | UNAUTHORIZED | Token JWT inv√°lido o expirado |
| 403 | FORBIDDEN | No tienes permisos para acceder al dashboard 5 |
| 429 | RATE_LIMIT_EXCEEDED | M√°ximo 5 explicaciones por minuto. Intenta en 45 segundos. |
| 503 | AI_SERVICE_UNAVAILABLE | Servicio de IA temporalmente no disponible. |
| 504 | AI_TIMEOUT | La generaci√≥n tard√≥ demasiado. |

Rate Limiting sugerido (Resilience4j / Bucket4j):
- `aiExplanation.limit-for-period=5`
- `aiExplanation.limit-refresh-period=60s`

---
## 9. Validaciones y Reglas
| Regla | Implementaci√≥n |
|-------|----------------|
| `dashboardId` > 0 | Bean Validation `@Min(1)` |
| Rango fechas ‚â§ 12 meses | Constructor record + diff months check |
| `fechaFin >= fechaInicio` | Constructor record |
| Filtros permitidos | Validar keys ‚àà permitted_filters YAML |
| Acceso dashboard | Reutilizar l√≥gica de MetabaseEmbeddingService o map roles/IDs |
| PII anonymization | Si `send_pii_to_gemini=false` ‚Üí reemplazar nombres por "Operario #N" |
| TTL din√°mico | M√©todo `calculateCacheTTL()` como en FP |
| JSON de Gemini v√°lido | `extractJsonFromResponse()` + `objectMapper.readValue()` + fallback |

---
## 10. Caching Strategy
- Motor: Caffeine (Spring Cache) ‚Äì spec global `maximumSize=10000,expireAfterWrite=9m` override local TTL manual (usar `Cache.put(key, value)` con wrapper que controla expiraci√≥n din√°mica si se requiere granularidad ‚Üí alternativa: instancia separada con spec simple y TTL program√°tico interno).
- Clave compuesta hashing de filtros: `String filtersHash = DigestUtils.sha256Hex(sortedJson(filtros))`.
- TTL: 24h si `fechaFin < today`, 30m si incluye hoy, fallback 5m.
- M√©tricas: hit/miss ratio (Micrometer gauge), tama√±o cache.

---
## 11. Gemini Integration
| Aspecto | Dise√±o |
|---------|--------|
| Cliente | `WebClient` bean existente (`WebClient.Builder`) |
| Timeout | **Total: 90s** (desglose):<br>- WebClient connect: 5s<br>- WebClient read: 85s<br>- Resilience4j TimeLimiter: 90s (global fallback)<br>Cualquiera que se active primero cancela la operaci√≥n |
| Retries | 503 / transient network: m√°x 2 intentos<br>Backoff exponencial: inicial 500ms, multiplicador 3x<br>(intento 1: espera 500ms, intento 2: espera 1500ms) |
| Modelo | Propiedad `gemini.model=gemini-1.5-flash` (ejemplo) |
| API Key | Env `GEMINI_API_KEY` (no commit) |
| Headers | `Authorization: Bearer <key>`, `Content-Type: application/json` |
| Token Estimation | Aproximaci√≥n `len/4` (reemplazable por conteo oficial futuro) |
| Sanitizaci√≥n | Asegurar respuesta JSON; si no parsea, fallback controlado |

Fallback Response (casos parsing error):
- `resumenEjecutivo` breve indicando error.
- `keyPoints` = ["Intenta nuevamente en unos momentos"].
- `alertas` contiene "Error en el servicio de IA" para visibilidad.

---
## 11.5. C√≥digo de Ejemplo (Snippets Gu√≠a)

### GeminiApiClient.java (Completo)

```java
package com.cambiaso.ioc.service.ai;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;

@Service
@Slf4j
@RequiredArgsConstructor
public class GeminiApiClient {

    private final WebClient.Builder webClientBuilder;
    
    @Value("${gemini.api-key}")
    private String apiKey;
    
    @Value("${gemini.model:gemini-1.5-flash}")
    private String model;
    
    @Value("${gemini.timeout.seconds:90}")
    private int timeoutSeconds;

    /**
     * Invoca la API de Gemini con el prompt completo.
     * Timeout: 5s connect + 85s read = 90s total.
     * Retries: 2 intentos con backoff exponencial (500ms, 1500ms).
     * 
     * @param prompt Prompt completo (system + context + data + instructions)
     * @return Respuesta JSON de Gemini como String
     * @throws GeminiApiException si falla despu√©s de retries
     */
    public String callGemini(String prompt) {
        log.debug("Calling Gemini API - Prompt length: {} chars", prompt.length());
        
        WebClient client = webClientBuilder
            .baseUrl("https://generativelanguage.googleapis.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
        
        String requestBody = buildRequestBody(prompt);
        
        try {
            String response = client.post()
                .uri("/v1/models/{model}:generateContent?key={apiKey}", model, apiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(String.class)
                .timeout(Duration.ofSeconds(timeoutSeconds))
                .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                    .maxBackoff(Duration.ofMillis(1500))
                    .filter(throwable -> throwable instanceof WebClientResponseException.ServiceUnavailable
                        || throwable instanceof java.net.ConnectException))
                .block();
            
            log.info("Gemini API call successful - Response length: {} chars", 
                response != null ? response.length() : 0);
            
            return extractTextFromGeminiResponse(response);
            
        } catch (Exception e) {
            log.error("Gemini API call failed after retries: {}", e.getMessage(), e);
            throw new GeminiApiException("Failed to get response from Gemini API", e);
        }
    }
    
    private String buildRequestBody(String prompt) {
        // Gemini API request format
        return String.format("""
            {
              "contents": [{
                "parts": [{"text": "%s"}]
              }],
              "generationConfig": {
                "temperature": 0.2,
                "maxOutputTokens": 2048
              }
            }
            """, escapeJson(prompt));
    }
    
    private String extractTextFromGeminiResponse(String response) {
        // Parse Gemini response structure: response.candidates[0].content.parts[0].text
        // Simplificado - en producci√≥n usar Jackson ObjectMapper
        try {
            int textStart = response.indexOf("\"text\":") + 8;
            int textEnd = response.indexOf("\"", textStart + 1);
            return response.substring(textStart, textEnd)
                .replace("\\n", "\n")
                .replace("\\\"", "\"");
        } catch (Exception e) {
            log.error("Failed to extract text from Gemini response", e);
            return response; // Fallback: retornar respuesta completa
        }
    }
    
    private String escapeJson(String text) {
        return text.replace("\\", "\\\\")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }
}
```

### DashboardExplanationService.java (Skeleton con fases)

```java
package com.cambiaso.ioc.service.ai;

import com.cambiaso.ioc.dto.ai.*;
import com.cambiaso.ioc.repository.DashboardAnalyticsRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
public class DashboardExplanationService {

    private final DashboardAnalyticsRepository analyticsRepository;
    private final GeminiApiClient geminiClient;
    private final ObjectMapper objectMapper;
    private final CacheManager cacheManager;
    
    private static final String CACHE_NAME = "aiExplanations";

    public DashboardExplanationResponse explainDashboard(DashboardExplanationRequest request) {
        long startTime = System.currentTimeMillis();
        
        // FASE 1: Verificar cache
        String cacheKey = buildCacheKey(request);
        Cache cache = cacheManager.getCache(CACHE_NAME);
        
        if (cache != null) {
            Cache.ValueWrapper cached = cache.get(cacheKey);
            if (cached != null) {
                log.info("Cache HIT for key: {}", cacheKey);
                DashboardExplanationResponse response = (DashboardExplanationResponse) cached.get();
                return response.withFromCache(true);
            }
        }
        
        log.info("Cache MISS - Starting AI explanation generation");
        
        // FASE 2: Consultar datos agregados (queries SQL)
        long queryStart = System.currentTimeMillis();
        TotalsDto totals = analyticsRepository.fetchTotals(request.fechaInicio(), request.fechaFin());
        List<TopOperarioDto> topOperarios = analyticsRepository.fetchTopOperarios(request.fechaInicio(), request.fechaFin());
        // ... m√°s queries
        long queryDuration = System.currentTimeMillis() - queryStart;
        log.debug("Queries completed in {}ms", queryDuration);
        
        // FASE 3: Construir prompt
        String prompt = buildPrompt(totals, topOperarios /*, ... */);
        
        // FASE 4: Invocar Gemini
        long geminiStart = System.currentTimeMillis();
        String geminiResponse = geminiClient.callGemini(prompt);
        long geminiDuration = System.currentTimeMillis() - geminiStart;
        
        // FASE 5: Parsear respuesta JSON
        DashboardExplanationResponse response = parseGeminiResponse(
            geminiResponse, 
            request,
            calculateCacheTTL(request.fechaInicio(), request.fechaFin())
        );
        
        // FASE 6: Guardar en cache
        if (cache != null) {
            cache.put(cacheKey, response);
        }
        
        // FASE 7: Auditor√≠a
        long totalDuration = System.currentTimeMillis() - startTime;
        logAudit(request, response, queryDuration, geminiDuration, totalDuration);
        
        return response;
    }
    
    /**
     * Calcula TTL de cache din√°micamente basado en frescura de datos.
     * - Datos hist√≥ricos (fechaFin < hoy): 24 horas
     * - Datos actuales (incluyen hoy): 30 minutos
     * - Fallback: 5 minutos
     */
    public int calculateCacheTTL(LocalDate fechaInicio, LocalDate fechaFin) {
        LocalDate today = LocalDate.now();
        
        if (fechaFin.isBefore(today)) {
            log.debug("Historical data detected - Cache TTL: 24h");
            return 86400; // 24 horas
        } else if (fechaFin.equals(today) || fechaFin.isAfter(today)) {
            log.debug("Current/future data detected - Cache TTL: 30min");
            return 1800; // 30 minutos
        }
        log.debug("Fallback TTL applied: 5min");
        return 300; // 5 minutos
    }
    
    private String buildCacheKey(DashboardExplanationRequest request) {
        // Clave compuesta: dashboardId + rango fechas + hash filtros
        String filtersHash = DigestUtils.sha256Hex(sortedJson(request.filtros()));
        return String.format("dashboard:%d:fi:%s:ff:%s:filters:%s", 
            request.dashboardId(), request.fechaInicio(), request.fechaFin(), filtersHash);
    }
    
    private String buildPrompt(TotalsDto totals, List<TopOperarioDto> topOperarios /*, ... */) {
        // Construir prompt para Gemini con secciones TOTALES, TOP_OPERARIOS, ...
        StringBuilder sb = new StringBuilder();
        sb.append("Sistema: ").append(System.lineSeparator());
        sb.append("Eres un experto analista de datos. Proporciona un an√°lisis ejecutivo claro y conciso.").append(System.lineSeparator());
        sb.append("Contexto: ").append(System.lineSeparator());
        sb.append("Dashboard: Producci√≥n Mensual").append(System.lineSeparator());
        sb.append("Fecha Inicio: ").append(totals.fechaInicio()).append(System.lineSeparator());
        sb.append("Fecha Fin: ").append(totals.fechaFin()).append(System.lineSeparator());
        sb.append("Filtros: ").append(totals.filtrosAplicados()).append(System.lineSeparator());
        sb.append("Datos: ").append(System.lineSeparator());
        sb.append("TOTALES: ").append(objectMapper.writeValueAsString(totals)).append(System.lineSeparator());
        sb.append("TOP_OPERARIOS: ").append(objectMapper.writeValueAsString(topOperarios)).append(System.lineSeparator());
        // ... m√°s secciones
        sb.append("Instrucciones: ").append(System.lineSeparator());
        sb.append("Genera el an√°lisis en JSON siguiendo el formato exacto del system prompt.");
        return sb.toString();
    }
    
    private DashboardExplanationResponse parseGeminiResponse(String response, 
        DashboardExplanationRequest request, int cacheTTL) {
        // Parsear respuesta JSON de Gemini a DashboardExplanationResponse
        try {
            GeminiJsonResponse geminiData = objectMapper.readValue(response, GeminiJsonResponse.class);
            return new DashboardExplanationResponse(
                geminiData.resumenEjecutivo(),
                geminiData.keyPoints(),
                geminiData.insightsAccionables(),
                geminiData.alertas(),
                request.dashboardId(),
                "Producci√≥n por Operario - Mensual",
                request.fechaInicio(),
                request.fechaFin(),
                request.filtros(),
                Instant.now(),
                false, // fromCache
                geminiData.tokensUsados(),
                cacheTTL
            );
        } catch (Exception e) {
            log.error("Error parsing Gemini response: {}", e.getMessage(), e);
            throw new RuntimeException("Error parsing Gemini response", e);
        }
    }
    
    private void logAudit(DashboardExplanationRequest request, 
        DashboardExplanationResponse response, long queryDuration, long geminiDuration, long totalDuration) {
        // Log estructurado para auditor√≠a
        log.info("""
            {
              "event": "AI_EXPLANATION",
              "user": "user123",
              "dashboardId": %d,
              "fromCache": %b,
              "latencyMs": %d,
              "geminiLatencyMs": %d,
              "tokens": %d,
              "cacheTTL": %d,
              "status": "SUCCESS"
            }
            """, 
            request.dashboardId(), 
            response.fromCache(),
            totalDuration,
            geminiDuration,
            response.tokensUsados(),
            response.cacheTTLSeconds());
    }
}
```

---
## 12. Seguridad & Compliance
| Tema | Medida |
|------|--------|
| Autenticaci√≥n | JWT (existente) |
| Autorizaci√≥n | `@PreAuthorize` + verificaci√≥n dashboard ‚Üî roles permitidos |
| Rate Limiting | Resilience4j / Bucket4j instancia `aiExplanation` |
| PII | Anonimizar `nombre_completo`, `usuario_sap` si pol√≠tica lo exige |
| Audit Log | Log estructurado (JSON) ‚Äì futuro persistencia tabla |
| Input Validation | Bean Validation + custom ctor checks |
| Prompt Injection | Backend controla prompt; no se aceptan fragmentos libres del usuario |
| Evasi√≥n de LLM | System prompt estricta + formato JSON obligatorio |
| DoS Gemini | Cache y rate limit; evaluar circuit breaker si 503 recurrente |

---
## 13. Performance & Latency Budget
| Fase | Objetivo | Riesgo |
|------|----------|--------|
| Cache Lookup | < 5 ms | Clave extensa ‚Üí hash r√°pido |
| Queries agregadas | 30‚Äì150 ms (rango mensual) | √çndices insuficientes para periodos largos > 6m |
| Prompt Build | < 10 ms | Serializaci√≥n JSON grande |
| Gemini Call | 2‚Äì8 s (pico) | Timeout 90s evita bloqueo infinito |
| Parsing | < 5 ms | Respuesta grande > 500 tokens |
| Total (miss) | < 10 s | Exceder ‚Üí usuario percibe lentitud |
| Total (hit) | < 150 ms | Suficiente para UX fluida |

Escalamiento: A√±adir precomputaci√≥n diaria nocturna de agregados para periodos hist√≥ricos.

---
## 14. Escalabilidad & Costos
| Escenario | Estrategia |
|-----------|-----------|
| >3 usuarios concurrentes | Migrar a paid tier inmediatamente |
| Incremento >10 | Introducir cola + persistencia de explicaciones |
| Picos de uso | Ajustar TTL m√°s largo en per√≠odos hist√≥ricos |
| Cost Control | M√©trica `ai_explanation_requests_total` vs l√≠mite mensual |

---
## 15. Observabilidad
M√©tricas Micrometer propuestas:
- `ai_explanation_requests_total` (counter, tags: outcome=success|error|timeout|rate_limited, cache=hit|miss)
- `ai_explanation_latency_ms` (timer, tags: phase=queries|gemini|total)
- `ai_explanation_tokens_used` (distribution summary)
- `ai_explanation_cache_size` (gauge)
- `ai_explanation_cache_ttl_seconds` (distribution summary)

Logs Estructurados (nivel INFO/ERROR):
```json
{
  "event": "AI_EXPLANATION",
  "user": "user123",
  "dashboardId": 5,
  "fromCache": false,
  "latencyMs": 2435,
  "geminiLatencyMs": 2100,
  "tokens": 1245,
  "cacheTTL": 1800,
  "status": "SUCCESS"
}
```

---
## 16. Testing Plan
### Backend
| Tipo | Caso |
|------|------|
| Unit | parseGeminiResponse JSON limpio |
| Unit | parseGeminiResponse con texto extra |
| Unit | calculateCacheTTL hist√≥rico vs actual |
| Unit | validaci√≥n fechas (rango >12m) |
| Unit | anonimizaci√≥n nombres |
| Integration | End-to-end endpoint (miss) con stub Gemini |
| Integration | Cache hit reiterado |
| Integration | Rate limit 429 |
| Integration | Timeout forzado simulado (usar WireMock) |
| Integration | Permiso dashboard denegado 403 |

### Frontend
| Tipo | Caso |
|------|------|
| Component | Fases de loading avanzan tiempo simulado |
| Component | Render JSON (keyPoints/insights/alertas) |
| Component | Manejo 429 countdown |
| Component | Fallback response vista correcta |
| E2E (opcional) | Clic bot√≥n ‚Üí muestra explicaci√≥n |

### No Funcionales
- Load test bajo: 20 requests/min comprobar latencia y cach√©.
- Resilience test: simular 503 Gemini ‚Üí fallback.

---
## 17. Plan de Implementaci√≥n (Tareas Secuenciadas)
### Backend
1. Crear DTOs records (request/response/analytics) + validaciones.
2. Implementar `DashboardAnalyticsRepository` + tests b√°sicos (mapeo filas).
3. Implementar `GeminiApiClient` (WebClient config + retries + timeout). 
4. Implementar `DashboardExplanationService` (cache, TTL, prompt build, parse, auditor√≠a, m√©tricas).
5. Implementar `AiExplanationController` con `@RateLimiter` + seguridad.
6. A√±adir propiedades `gemini.*` y `aiExplanation.*` (rate limit) y documentar en README.
7. A√±adir m√©tricas Micrometer (timers, counters) y logging estructurado.
8. Tests unitarios & integraci√≥n (usar stub cliente Gemini / WireMock).
9. Revisi√≥n de seguridad (PII anonimizaci√≥n) y ajuste final del prompt.

### Frontend
1. Crear `ExplainDashboardButton.tsx` + fases de loading.
2. Crear `ExplanationModal.tsx` render secciones desde JSON.
3. Servicio API `aiExplanationService.ts` con gesti√≥n retries y manejo errores.
4. Integrar bot√≥n en `DashboardEmbed.tsx` (posici√≥n absoluta).
5. Manejo errores (429 countdown, 503/504 reintentar).
6. Tests de componentes con Vitest/Testing Library.
7. E2E exploratorio (opcional) en staging.

### Rollout
1. Activar s√≥lo `ROLE_ADMIN` (flag en controller / PreAuthorize).
2. Monitorear m√©tricas tokens y latencia 3 d√≠as.
3. Evaluar necesidad paid tier.
4. Expandir a `ROLE_MANAGER` si costo aceptable.

---
## 18. Prompt Construction ‚Äì Detalle T√©cnico
Orden concatenaci√≥n:
1. System Prompt base (archivo system-prompt). 
2. Bloque contexto negocio (YAML parseado ‚Üí lista de l√≠neas clave). 
3. Bloque datos agregados formateados (secciones: TOTALES, TOP_OPERARIOS, DISTRIBUCI√ìN_TURNO, TOP_M√ÅQUINAS, TENDENCIA_DIARIA). 
4. Instrucci√≥n final: "Genera el an√°lisis en JSON siguiendo el formato exacto del system prompt".

Sanitizaci√≥n PII (si desactivado):
- Reemplazar cada nombre completo con `Operario #<ordinal>` manteniendo orden por unidades.

---
## 19. Edge Cases & Manejo de Errores
| Edge Case | Acci√≥n |
|-----------|--------|
| Rango vac√≠o (`fechaInicio==fechaFin` sin datos) | Resumen indica "Sin registros"; keyPoints m√≠nimo 1 item admonitorio |
| Sin operarios activos | keyPoints: "No se detectaron operarios activos" |
| Gemini retorna texto no JSON | Fallback response + alerta error IA |
| Retry agotado (503 persistente) | 503 al cliente + recomendaci√≥n reintentar |
| Timeout (90s) | 504 + sugerir rango menor |
| Filtros no permitidos | 400 VALIDATION_ERROR |
| Dashboard no autorizado | 403 FORBIDDEN |
| Cache hit expira durante build | Recalcular completa (rare ‚Äì no acci√≥n especial) |

---
## 20. Riesgos & Mitigaciones
| Riesgo | Impacto | Mitigaci√≥n |
|--------|---------|-----------|
| Respuesta Gemini inconsistente | UX pobre | Formato JSON estricto + validaci√≥n + fallback |
| Costos IA exceden free tier | Bloqueos | M√©tricas y rollout gradual + cache agresiva |
| Latencia alta (>10s) | Mala UX | Optimizar queries, reducir tama√±o prompt, pre-agregaci√≥n |
| Sobre-exposici√≥n PII | Cumplimiento legal | Flag `send_pii_to_gemini` + anonimizaci√≥n predeterminada |
| Falta de √≠ndices para producci√≥n hist√≥rica | Slowness | A√±adir √≠ndices compuestos tras monitoreo |
| Errores de mapping SQL | Datos incorrectos | Tests unitarios repositorio + revisi√≥n manual |

---
## 21. Extensibilidad Futura
| Feature | Ajuste |
|---------|--------|
| Persistir explicaciones | A√±adir tabla `ai_explanation_store` + TTL expiraci√≥n |
| Sistema de cola | Introducir Kafka / Rabbit + worker as√≠ncrono |
| Multi-model AI | Strategy Pattern `AiModelClient` (Gemini/OpenAI/Claude) |
| Streaming de tokens | WebSocket endpoint para mostrar avance |
| Pre-c√°lculo nocturno | Job Spring Scheduler + guardar agregados en tabla summary |

---
## 22. Checklist Implementaci√≥n (Backend)
- [ ] DTOs creados y validados
- [ ] Repositorio anal√≠tico implementado
- [ ] Servicio explicaci√≥n con cache TTL din√°mico
- [ ] Cliente Gemini (timeout + retry + m√©tricas)
- [ ] Controller + seguridad + rate limit
- [ ] Propiedades a√±adidas y documentadas
- [ ] Logs estructurados activos
- [ ] M√©tricas Micrometer registradas
- [ ] Tests unitarios (parsing, cache, validaciones)
- [ ] Tests integraci√≥n endpoint + stub Gemini
- [ ] Revisi√≥n PII anonimizaci√≥n

### Checklist Frontend
- [ ] Bot√≥n y modal UX
- [ ] Fases de loading funcionales
- [ ] Servicio API integraci√≥n backend
- [ ] Manejo errores 429/503/504
- [ ] Render secciones JSON
- [ ] Tests componentes clave

---
## 23. Propiedades & Configuraci√≥n (propuestas)
Agregar a `application.properties` o perfil:
```
# Gemini
gemini.api-key=${GEMINI_API_KEY}
gemini.model=gemini-1.5-flash
gemini.timeout.seconds=90
gemini.retry.max-attempts=2
gemini.retry.backoff.initial=500ms
gemini.retry.backoff.max=1500ms

# AI Explanation Rate Limiting (Resilience4j)
resilience4j.ratelimiter.instances.aiExplanation.limit-for-period=5
resilience4j.ratelimiter.instances.aiExplanation.limit-refresh-period=60s
resilience4j.ratelimiter.instances.aiExplanation.timeout-duration=0s
```

---
## 23.5. Dependencias Maven Requeridas

### ‚úÖ Dependencias Ya Existentes en pom.xml (No Agregar)

Las siguientes dependencias **ya est√°n presentes** en el proyecto y ser√°n reutilizadas:

```xml
<!-- WebClient para llamadas HTTP reactivas -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webflux</artifactId>
</dependency>
<dependency>
    <groupId>io.projectreactor.netty</groupId>
    <artifactId>reactor-netty</artifactId>
</dependency>

<!-- Cache con Caffeine -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>

<!-- Resilience4j para Rate Limiting y Circuit Breaker -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.1.0</version>
</dependency>

<!-- Jackson para parsing JSON -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>

<!-- Spring Boot starters necesarios -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

### ‚ö†Ô∏è Dependencia a Verificar/Agregar

**Apache Commons Codec** (para `DigestUtils.sha256Hex` usado en hashing de filtros):

```xml
<!-- Agregar si no existe -->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.16.0</version>
</dependency>
```

**Verificaci√≥n**: Ejecutar `mvn dependency:tree | grep commons-codec` para confirmar si ya est√° incluido transitivamente.

### üìã Resumen de Dependencias para FP-001A

| Dependencia | Estado | Uso en Feature |
|-------------|--------|----------------|
| spring-webflux + reactor-netty | ‚úÖ Existe | GeminiApiClient (WebClient) |
| caffeine | ‚úÖ Existe | Cache de explicaciones |
| resilience4j-spring-boot3 | ‚úÖ Existe | Rate limiting endpoint |
| jackson-databind | ‚úÖ Existe | Parsing JSON de Gemini |
| spring-boot-starter-validation | ‚úÖ Existe | Validaci√≥n DTOs |
| spring-boot-starter-data-jpa | ‚úÖ Existe | Acceso a fact_production |
| commons-codec | ‚ö†Ô∏è Verificar | Hash SHA256 de filtros |

**Acci√≥n recomendada**: 
1. Verificar `commons-codec` con `mvn dependency:tree`.
2. Si falta, agregar la dependencia indicada arriba.
3. No agregar ninguna otra dependencia nueva.

---
## 24. M√©tricas de √âxito (del FP adaptadas a TD)
| M√©trica | Objetivo |
|---------|----------|
| Tiempo medio generaci√≥n (miss) | < 8s |
| Ratio cache hit | > 60% despu√©s de 7 d√≠as |
| Errores parsing IA | < 5% de invocaciones |
| Uso tokens / request | < 1500 tokens promedio |
| L√≠mite IA excedido | 0 en horario laboral tras rollout |
| Satisfacci√≥n usuarios admin | >=80% (encuesta interna) |

---
## 25. Referencias
- FP-001A-dashboard-ai-explanation-A.md (v0.4)
- System Prompt: FP-001A-system-prompt.txt
- Contexto negocio: FP-001A-context.yaml
- Project Summary general.

---
## 26. Aprobaciones Requeridas
| Rol | Revisi√≥n |
|-----|----------|
| Tech Lead | Arquitectura, seguridad, performance |
| Product Owner | Alcance y UX confirmados |
| Data Team | Validaci√≥n queries y sem√°ntica m√©tricas |
| Legal (si PII) | Pol√≠tica anonimizaci√≥n |

---
## 27. Estado Actual
TD generado. Pendiente validaci√≥n de pre-requisitos incompletos marcados en FP (confirmar actualizaci√≥n de datos, presupuesto, concurrencia m√°xima).

---
## 28. Pr√≥ximos Pasos Inmediatos
1. Validar pre-requisitos bloqueantes pendientes (datos / presupuesto / usuarios simult√°neos).
2. Crear rama `feature/fp-001A-ai-dashboard-explanation`.
3. Implementar tareas backend (ver secci√≥n 17).
4. Revisar latencias y ajuste prompt iterativo.
5. Rollout controlado a ROLE_ADMIN.

---
Fin del documento ‚Äì TD-001A.
