# ===================================================================
# CONFIGURACI\u00D3N DE PRODUCCI\u00D3N (RENDER) - SINGLE DATASOURCE
# ===================================================================

# PRIMARY DATASOURCE - Transaction Mode (Port 6543)
# Usado para todas las operaciones JPA/Hibernate (queries, inserts, updates, deletes)
# IMPORTANT: disable server-side prepared statements / use simple query mode when using a pooler
# This prevents errors like "prepared statement "S_1" does not exist" when connections are switched by the pooler.
spring.datasource.url=jdbc:postgresql://aws-1-sa-east-1.pooler.supabase.com:6543/postgres?reWriteBatchedInserts=true&prepareThreshold=0&preferQueryMode=simple
spring.datasource.username=postgres.bdyvzjpkycnekjrlqlfp
spring.datasource.password=${SUPABASE_DB_PASSWORD}

# ===================================================================
# CONFIGURACION DE HIKARICP POOL - CRITICO PARA SUPABASE FREE TIER
# ===================================================================
# Pool de conexiones MINIMO para Supabase free tier (max 3 conexiones simultaneas)
spring.datasource.hikari.maximum-pool-size=3
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.connection-timeout=30000
# Tiempos mas cortos para evitar que Supabase cierre conexiones antes que Hikari
spring.datasource.hikari.idle-timeout=240000
spring.datasource.hikari.max-lifetime=300000
# Keepalive para mantener conexiones vivas
spring.datasource.hikari.keepalive-time=120000
spring.datasource.hikari.validation-timeout=3000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.leak-detection-threshold=60000

# ===================================================================
# CONFIGURACION DE JPA & HIBERNATE
# ===================================================================

# NO mostrar SQL en producci\u00F3n por performance (genera miles de logs innecesarios)
spring.jpa.show-sql=false

# Estrategia de generacion de esquema
spring.jpa.hibernate.ddl-auto=update

# Mantiene los nombres de las columnas igual que en las entidades (camelCase)
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Desactiva Open-In-View para promover buenas practicas y mejorar el rendimiento
spring.jpa.open-in-view=false

# Propiedades de optimizacion de Hibernate para batching
# CRITICO: batch_size debe coincidir con allocationSize de la secuencia (100)
spring.jpa.properties.hibernate.jdbc.batch_size=100
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.generate_statistics=false

# CR\u00CDTICO: Configuraciones adicionales para habilitar batch inserts con secuencias
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.id.new_generator_mappings=true
spring.jpa.properties.hibernate.jdbc.fetch_size=100

# Habilita el uso de secuencias optimizadas (pooled) para batch inserts
spring.jpa.properties.hibernate.id.optimizer.pooled.prefer_lo=true

# Deshabilita auto-flush durante batch operations para mejor performance
spring.jpa.properties.hibernate.jdbc.batch_on_entity_mapping=true

# ===================================================================
# CONFIGURACION DE SEGURIDAD (SUPABASE AUTH)
# ===================================================================
spring.security.oauth2.resourceserver.jwt.issuer-uri=${SUPABASE_JWT_ISSUER_URI}

# ===================================================================
# CONFIGURACION DE MONITOREO Y RENDIMIENTO
# ===================================================================

# Actuator Configuration for Monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus,info
management.endpoint.health.show-details=when-authorized

# Custom metrics configuration
management.metrics.tags.application=ioc-backend
management.metrics.tags.version=@project.version@

# Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.notification-service.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.notification-service.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.notification-service.sliding-window-size=10
resilience4j.circuitbreaker.instances.notification-service.minimum-number-of-calls=5

# Cache Configuration for Rate Limiting
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=9m

# ===================================================================
# CONFIGURACION DE SUBIDA DE ARCHIVOS (MULTIPART)
# ===================================================================
# Tamano maximo por archivo (50MB)
spring.servlet.multipart.max-file-size=50MB
# Tamano maximo de la peticion completa (50MB)
spring.servlet.multipart.max-request-size=50MB

# ===================================================================
# CONFIGURACION ETL (FEATURE FLAGS)
# ===================================================================
# Temporarily disable advisory lock on Render due to session-mode connection issues
etl.lock.enabled=false
# Habilita chequeo de duplicados al inicio (solo log warning)
etl.duplicate.check.enabled=true
# Si se desea fallar el arranque si hay duplicados (antes de aplicar UNIQUE)
etl.duplicate.fail-on-detect=false
# Cuantos grupos de duplicados loggear como muestra
etl.duplicate.check.sample-limit=10
# Retry por colision UNIQUE (cuando se active constraint en futuro)
etl.retry.unique.enabled=true
etl.retry.unique.max-attempts=5
# (Futuro) Enforcer de UNIQUE: activar solo cuando se haya limpiado data
etl.unique.enforced=false
# Threshold para jobs stuck
etl.jobs.stuck.threshold-minutes=30
# Watchdog de jobs (termina jobs stuck a FALLO y registra etl.jobs.watchdog.terminations)
# etl.jobs.watchdog.enabled=true
# etl.jobs.watchdog.interval-ms=60000

# ===================================================================
# CONFIGURACION DE METABASE EMBEDDING
# ===================================================================
# Usa Cloudflare Tunnel para acceso HTTPS (requerido para Vercel)
metabase.site-url=${METABASE_URL:https://treated-paste-eos-memo.trycloudflare.com}
metabase.secret-key=${METABASE_SECRET_KEY}
metabase.token-expiration-minutes=10

# Dashboards Permitidos
metabase.dashboards[0].id=1
metabase.dashboards[0].name=Dashboard Gerencial
metabase.dashboards[0].description=M\u00E9tricas ejecutivas y KPIs principales
metabase.dashboards[0].allowed-roles=ROLE_ADMIN,ROLE_MANAGER
metabase.dashboards[0].filters[0].name=user_id
metabase.dashboards[0].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[0].source=userId
metabase.dashboards[0].filters[1].name=department
metabase.dashboards[0].filters[1].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[1].source=department

metabase.dashboards[1].id=3
metabase.dashboards[1].name=Dashboard Operacional Prueba
metabase.dashboards[1].description=M\u00E9tricas operativas diarias de prueba
metabase.dashboards[1].allowed-roles=ROLE_USER,ROLE_ADMIN
metabase.dashboards[1].filters[0].name=user_id
metabase.dashboards[1].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[1].filters[0].source=userId

# ===================================================================
# CONFIGURACION DE RESILIENCE4J (CIRCUIT BREAKER)
# ===================================================================
resilience4j.circuitbreaker.instances.metabaseService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.metabaseService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.metabaseService.sliding-window-size=10
resilience4j.circuitbreaker.instances.metabaseService.permitted-number-of-calls-in-half-open-state=3

# ===================================================================
# CONFIGURACION DE RATE LIMITING PARA DASHBOARDS
# ===================================================================
# Limita a 10 requests por usuario cada 60 segundos
resilience4j.ratelimiter.instances.dashboardAccess.limit-for-period=10
resilience4j.ratelimiter.instances.dashboardAccess.limit-refresh-period=60s
resilience4j.ratelimiter.instances.dashboardAccess.timeout-duration=0s
