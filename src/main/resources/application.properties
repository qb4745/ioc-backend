# ===================================================================
# CONFIGURACION LOCAL DE LA BASE DE DATOS (USANDO CONNECTION POOLER)
# ===================================================================

# URL de conexion al Pooler de Supabase
spring.datasource.url=jdbc:postgresql://aws-1-sa-east-1.pooler.supabase.com:5432/postgres?reWriteBatchedInserts=true

# El 'username' para el Pooler incluye el ID del proyecto
spring.datasource.username=postgres.bdyvzjpkycnekjrlqlfp

# La contrasena se inyecta de forma segura desde una variable de entorno
spring.datasource.password=${SUPABASE_DB_PASSWORD}


# ===================================================================
# CONFIGURACION DE JPA & HIBERNATE
# ===================================================================

# Muestra las consultas SQL en la consola durante el desarrollo
spring.jpa.show-sql=true

# Estrategia de generacion de esquema. 'update' es ideal para desarrollo.
spring.jpa.hibernate.ddl-auto=update

# Mantiene los nombres de las columnas igual que en las entidades (camelCase)
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Desactiva Open-In-View para promover buenas practicas y mejorar el rendimiento
spring.jpa.open-in-view=false

# Propiedades de optimizacion de Hibernate para batching
spring.jpa.properties.hibernate.jdbc.batch_size=500
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.generate_statistics=true

# ===================================================================
# CONFIGURACION DE SEGURIDAD (SUPABASE AUTH)
# ===================================================================
spring.security.oauth2.resourceserver.jwt.issuer-uri=${SUPABASE_JWT_ISSUER_URI}

# ===================================================================
# CONFIGURACION DE MONITOREO Y RENDIMIENTO
# ===================================================================

# Actuator Configuration for Monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus,info
management.endpoint.health.show-details=when-authorized

# Custom metrics configuration
management.metrics.tags.application=ioc-backend
management.metrics.tags.version=@project.version@

# Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.notification-service.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.notification-service.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.notification-service.sliding-window-size=10
resilience4j.circuitbreaker.instances.notification-service.minimum-number-of-calls=5

# Cache Configuration for Rate Limiting
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=9m

# ===================================================================
# CONFIGURACION DE SUBIDA DE ARCHIVOS (MULTIPART)
# ===================================================================
# Tamano maximo por archivo (50MB)
spring.servlet.multipart.max-file-size=50MB
# Tamano maximo de la peticion completa (50MB)
spring.servlet.multipart.max-request-size=50MB

# ===================================================================
# CONFIGURACION ETL (FEATURE FLAGS)
# ===================================================================
# Habilita el advisory lock para evitar solapamiento de rangos (hardening IOC-022)
etl.lock.enabled=true
# Habilita chequeo de duplicados al inicio (solo log warning)
etl.duplicate.check.enabled=true
# Si se desea fallar el arranque si hay duplicados (antes de aplicar UNIQUE)
etl.duplicate.fail-on-detect=false
# Cuantos grupos de duplicados loggear como muestra
etl.duplicate.check.sample-limit=10
# Retry por colision UNIQUE (cuando se active constraint en futuro)
etl.retry.unique.enabled=true
etl.retry.unique.max-attempts=5
# (Futuro) Enforcer de UNIQUE: activar solo cuando se haya limpiado data
etl.unique.enforced=false
# Threshold para jobs stuck
etl.jobs.stuck.threshold-minutes=30
# Watchdog de jobs (termina jobs stuck a FALLO y registra etl.jobs.watchdog.terminations)
# etl.jobs.watchdog.enabled=true
# etl.jobs.watchdog.interval-ms=60000

# ===================================================================
# CONFIGURACION DE METABASE EMBEDDING
# ===================================================================
# metabase.site-url=${METABASE_URL:http://localhost:3000}
metabase.site-url=${METABASE_URL:http://54.232.229.228:3000}
metabase.secret-key=${METABASE_SECRET_KEY}
metabase.token-expiration-minutes=10

# Dashboards Permitidos
metabase.dashboards[0].id=1
metabase.dashboards[0].name=Dashboard Gerencial
metabase.dashboards[0].description=Metricas ejecutivas y KPIs principales
metabase.dashboards[0].allowed-roles=ROLE_ADMIN,ROLE_MANAGER
metabase.dashboards[0].filters[0].name=user_id
metabase.dashboards[0].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[0].source=userId
metabase.dashboards[0].filters[1].name=department
metabase.dashboards[0].filters[1].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[1].source=department

metabase.dashboards[1].id=3
metabase.dashboards[1].name=Dashboard Operacional Prueba
metabase.dashboards[1].description=Métricas operativas diarias de prueba
metabase.dashboards[1].allowed-roles=ROLE_USER,ROLE_ADMIN
metabase.dashboards[1].filters[0].name=user_id
metabase.dashboards[1].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[1].filters[0].source=userId

# ===================================================================
# CONFIGURACION DE RESILIENCE4J (CIRCUIT BREAKER)
# ===================================================================
resilience4j.circuitbreaker.instances.metabaseService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.metabaseService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.metabaseService.sliding-window-size=10
resilience4j.circuitbreaker.instances.metabaseService.permitted-number-of-calls-in-half-open-state=3

# ===================================================================
# CONFIGURACION DE RATE LIMITING PARA DASHBOARDS
# ===================================================================
# Limita a 10 requests por usuario cada 60 segundos
resilience4j.ratelimiter.instances.dashboardAccess.limit-for-period=10
resilience4j.ratelimiter.instances.dashboardAccess.limit-refresh-period=60s
resilience4j.ratelimiter.instances.dashboardAccess.timeout-duration=0s

# Activate "dev" profile by default for local development
# spring.profiles.active=dev
