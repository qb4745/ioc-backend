# ===================================================================
# CONFIGURACION LOCAL DE LA BASE DE DATOS (USANDO CONNECTION POOLER)
# ===================================================================

# URL de conexion al Pooler de Supabase - Transaction Mode (Puerto 6543)
# CRITICO: Usar puerto 6543 para que las conexiones se liberen autom\u00E1ticamente
# IMPORTANT: disable server-side prepared statements / use simple query mode when using a pooler (pgbouncer/Supavisor)
# - preferQueryMode=simple forces the driver to use the simple protocol (no server-side prepared statements)
# - prepareThreshold=0 disables the driver's use of server-side prepared statements
# This prevents errors like "prepared statement \"S_1\" does not exist" when connections are switched by the pooler.
spring.datasource.url=jdbc:postgresql://aws-1-sa-east-1.pooler.supabase.com:6543/postgres?reWriteBatchedInserts=true&prepareThreshold=0&preferQueryMode=simple

# El 'username' para el Pooler incluye el ID del proyecto
spring.datasource.username=postgres.bdyvzjpkycnekjrlqlfp

# La contrasena se inyecta de forma segura desde una variable de entorno
spring.datasource.password=${SUPABASE_DB_PASSWORD}

# ===================================================================
# CONFIGURACION DE HIKARICP POOL - OPTIMIZADO PARA SUPABASE FREE TIER
# ===================================================================
# Limite de conexiones para Supabase free tier (max 3-5 conexiones)
spring.datasource.hikari.maximum-pool-size=3
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=540000
spring.datasource.hikari.keepalive-time=120000
spring.datasource.hikari.validation-timeout=5000
spring.datasource.hikari.leak-detection-threshold=60000


# ===================================================================
# CONFIGURACION DE JPA & HIBERNATE
# ===================================================================

# Muestra las consultas SQL en la consola durante el desarrollo
spring.jpa.show-sql=true

# Estrategia de generacion de esquema. 'update' es ideal para desarrollo.
spring.jpa.hibernate.ddl-auto=update

# Mantiene los nombres de las columnas igual que en las entidades (camelCase)
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Desactiva Open-In-View para promover buenas practicas y mejorar el rendimiento
spring.jpa.open-in-view=false

# Propiedades de optimizacion de Hibernate para batching
# CRITICO: batch_size debe coincidir con allocationSize de la secuencia (100)
spring.jpa.properties.hibernate.jdbc.batch_size=100
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.generate_statistics=true

# ===================================================================
# CONFIGURACION DE SEGURIDAD (SUPABASE AUTH)
# ===================================================================
spring.security.oauth2.resourceserver.jwt.issuer-uri=${SUPABASE_JWT_ISSUER_URI}

# ===================================================================
# CONFIGURACION DE MONITOREO Y RENDIMIENTO
# ===================================================================

# Actuator Configuration for Monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus,info
management.endpoint.health.show-details=when-authorized

# Custom metrics configuration
management.metrics.tags.application=ioc-backend
management.metrics.tags.version=@project.version@

# Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.notification-service.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.notification-service.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.notification-service.sliding-window-size=10
resilience4j.circuitbreaker.instances.notification-service.minimum-number-of-calls=5

# Cache Configuration for Rate Limiting
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=9m

# ===================================================================
# CONFIGURACION DE SUBIDA DE ARCHIVOS (MULTIPART)
# ===================================================================
# Tamano maximo por archivo (50MB)
spring.servlet.multipart.max-file-size=50MB
# Tamano maximo de la peticion completa (50MB)
spring.servlet.multipart.max-request-size=50MB

# ===================================================================
# CONFIGURACION ETL (FEATURE FLAGS)
# ===================================================================
# Deshabilitar advisory lock (no hay datasource secundario despu\u00E9s del git reset)
etl.lock.enabled=false
# Habilita chequeo de duplicados al inicio (solo log warning)
etl.duplicate.check.enabled=true
# Si se desea fallar el arranque si hay duplicados (antes de aplicar UNIQUE)
etl.duplicate.fail-on-detect=false
# Cuantos grupos de duplicados loggear como muestra
etl.duplicate.check.sample-limit=10
# Retry por colision UNIQUE (cuando se active constraint en futuro)
etl.retry.unique.enabled=true
etl.retry.unique.max-attempts=5
# (Futuro) Enforcer de UNIQUE: activar solo cuando se haya limpiado data
etl.unique.enforced=false
# Threshold para jobs stuck
etl.jobs.stuck.threshold-minutes=30
# Watchdog de jobs (termina jobs stuck a FALLO y registra etl.jobs.watchdog.terminations)
# etl.jobs.watchdog.enabled=true
# etl.jobs.watchdog.interval-ms=60000

# ===================================================================
# CONFIGURACION DE METABASE EMBEDDING
# ===================================================================
# Usa Cloudflare Tunnel para acceso HTTPS (requerido para Vercel)
metabase.site-url=https://treated-paste-eos-memo.trycloudflare.com
metabase.secret-key=${METABASE_SECRET_KEY}
metabase.token-expiration-minutes=10

# Dashboards Permitidos
metabase.dashboards[0].id=1
metabase.dashboards[0].name=Dashboard Gerencial
metabase.dashboards[0].description=M\u00E9tricas ejecutivas y KPIs principales
metabase.dashboards[0].allowed-roles=ROLE_ADMIN,ROLE_MANAGER
metabase.dashboards[0].filters[0].name=user_id
metabase.dashboards[0].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[0].source=userId
metabase.dashboards[0].filters[1].name=department
metabase.dashboards[0].filters[1].type=USER_ATTRIBUTE
metabase.dashboards[0].filters[1].source=department

metabase.dashboards[1].id=3
metabase.dashboards[1].name=Dashboard Operacional Prueba
metabase.dashboards[1].description=M\u00E9tricas operativas diarias de prueba
metabase.dashboards[1].allowed-roles=ROLE_USER,ROLE_ADMIN
metabase.dashboards[1].filters[0].name=user_id
metabase.dashboards[1].filters[0].type=USER_ATTRIBUTE
metabase.dashboards[1].filters[0].source=userId

# ===================================================================
# CONFIGURACION DE RESILIENCE4J (CIRCUIT BREAKER)
# ===================================================================
resilience4j.circuitbreaker.instances.metabaseService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.metabaseService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.metabaseService.sliding-window-size=10
resilience4j.circuitbreaker.instances.metabaseService.permitted-number-of-calls-in-half-open-state=3

# ===================================================================
# CONFIGURACION DE RATE LIMITING PARA DASHBOARDS
# ===================================================================
# Limita a 10 requests por usuario cada 60 segundos
resilience4j.ratelimiter.instances.dashboardAccess.limit-for-period=10
resilience4j.ratelimiter.instances.dashboardAccess.limit-refresh-period=60s
resilience4j.ratelimiter.instances.dashboardAccess.timeout-duration=0s

# Activate "dev" profile by default for local development
# spring.profiles.active=dev