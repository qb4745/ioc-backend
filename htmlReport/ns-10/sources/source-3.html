


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DataSyncService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.cambiaso.ioc.service</a>
</div>

<h1>Coverage Summary for Class: DataSyncService (com.cambiaso.ioc.service)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DataSyncService</td>
<td class="coverageStat">
  <span class="percent">
    5.6%
  </span>
  <span class="absValue">
    (1/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.8%
  </span>
  <span class="absValue">
    (1/126)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DataSyncService$DataSyncException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    5.3%
  </span>
  <span class="absValue">
    (1/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.8%
  </span>
  <span class="absValue">
    (1/127)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.cambiaso.ioc.service;
&nbsp;
&nbsp;import com.cambiaso.ioc.persistence.entity.FactProduction;
&nbsp;import com.cambiaso.ioc.persistence.repository.FactProductionRepository;
&nbsp;import io.micrometer.core.instrument.MeterRegistry;
&nbsp;import io.micrometer.core.instrument.Counter;
&nbsp;import io.micrometer.core.instrument.Timer;
&nbsp;import io.micrometer.core.instrument.DistributionSummary;
&nbsp;import jakarta.persistence.EntityManager;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.dao.DataIntegrityViolationException;
&nbsp;import org.springframework.lang.NonNull;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.transaction.annotation.Transactional;
&nbsp;import org.springframework.transaction.support.TransactionTemplate;
&nbsp;
&nbsp;import java.time.Duration;
&nbsp;import java.time.LocalDate;
&nbsp;import java.util.List;
&nbsp;
<b class="fc">&nbsp;@Slf4j</b>
&nbsp;@Service
&nbsp;@RequiredArgsConstructor
&nbsp;public class DataSyncService {
&nbsp;
&nbsp;    private final FactProductionRepository factProductionRepository;
&nbsp;    private final EntityManager entityManager; // Para advisory lock
&nbsp;    private final MeterRegistry meterRegistry;
&nbsp;    private final TransactionTemplate transactionTemplate; // Ejecuta bloques transaccionales explícitos
&nbsp;
&nbsp;    @Value(&quot;${etl.lock.enabled:true}&quot;)
&nbsp;    private boolean etlLockEnabled;
&nbsp;    @Value(&quot;${etl.retry.unique.enabled:false}&quot;)
&nbsp;    private boolean retryUniqueEnabled;
&nbsp;    @Value(&quot;${etl.retry.unique.max-attempts:3}&quot;)
&nbsp;    private int retryMaxAttempts;
&nbsp;    @Value(&quot;${etl.lock.test.sleep-ms:0}&quot;)
&nbsp;    private long lockTestSleepMs; // SOLO para pruebas: delay artificial tras tomar el lock
&nbsp;    @Value(&quot;${etl.sync.test.sleep-ms:0}&quot;)
&nbsp;    private long syncTestSleepMs; // SOLO tests: pausa tras delete antes de inserts
&nbsp;
&nbsp;    // Métricas (lazily inicializadas)
<b class="nc">&nbsp;    private Counter rowsDeletedCounter() { return meterRegistry.counter(&quot;etl.rows.deleted&quot;); }</b>
<b class="nc">&nbsp;    private Counter rowsInsertedCounter() { return meterRegistry.counter(&quot;etl.rows.inserted&quot;); }</b>
<b class="nc">&nbsp;    private Timer syncDurationTimer() { return meterRegistry.timer(&quot;etl.sync.duration&quot;); }</b>
<b class="nc">&nbsp;    private Counter syncAttemptCounter() { return meterRegistry.counter(&quot;etl.sync.attempts&quot;); }</b>
<b class="nc">&nbsp;    private Counter syncCollisionCounter() { return meterRegistry.counter(&quot;etl.sync.collisions&quot;); }</b>
<b class="nc">&nbsp;    private DistributionSummary windowDaysSummary() { return DistributionSummary.builder(&quot;etl.sync.window.days&quot;).publishPercentileHistogram().register(meterRegistry); }</b>
<b class="nc">&nbsp;    private DistributionSummary batchSizeSummary() { return DistributionSummary.builder(&quot;etl.sync.records.per.batch&quot;).publishPercentileHistogram().register(meterRegistry); }</b>
&nbsp;
&nbsp;    public void syncWithDeleteInsert(LocalDate minDate, LocalDate maxDate, @NonNull List&lt;FactProduction&gt; records) {
<b class="nc">&nbsp;        if (!retryUniqueEnabled) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                syncAttemptCounter().increment();</b>
<b class="nc">&nbsp;                executeOnce(minDate, maxDate, records);</b>
&nbsp;            } catch (DataIntegrityViolationException dive) {
<b class="nc">&nbsp;                throw new DataSyncException(buildErr(minDate, maxDate, &quot;data integrity violation&quot;), dive);</b>
&nbsp;            } catch (RuntimeException e) {
<b class="nc">&nbsp;                if (isUniqueConstraintViolation(e)) {</b>
<b class="nc">&nbsp;                    log.warn(&quot;Unique constraint violation (no-retry mode) for range {} to {}: {}&quot;, minDate, maxDate, e.getMessage());</b>
&nbsp;                }
<b class="nc">&nbsp;                throw new DataSyncException(buildErr(minDate, maxDate, &quot;unexpected failure&quot;), e);</b>
&nbsp;            }
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        int attempt = 0;</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            attempt++;</b>
<b class="nc">&nbsp;            syncAttemptCounter().increment();</b>
&nbsp;            try {
<b class="nc">&nbsp;                executeOnce(minDate, maxDate, records);</b>
<b class="nc">&nbsp;                if (attempt &gt; 1) {</b>
<b class="nc">&nbsp;                    log.info(&quot;ETL sync succeeded after {} attempt(s) (unique collision retry mode)&quot;, attempt);</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            } catch (DataIntegrityViolationException dive) {
<b class="nc">&nbsp;                if (!handleOrRetry(minDate, maxDate, attempt, dive, records)) {</b>
<b class="nc">&nbsp;                    throw new DataSyncException(buildErr(minDate, maxDate, &quot;data integrity violation (final)&quot;), dive);</b>
&nbsp;                }
&nbsp;            } catch (RuntimeException e) {
<b class="nc">&nbsp;                boolean unique = isUniqueConstraintViolation(e);</b>
<b class="nc">&nbsp;                if (unique) {</b>
<b class="nc">&nbsp;                    if (!handleOrRetry(minDate, maxDate, attempt, e, records)) {</b>
<b class="nc">&nbsp;                        throw new DataSyncException(buildErr(minDate, maxDate, &quot;data integrity violation (final)&quot;), e);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    log.error(&quot;Non-unique runtime exception during sync (attempt {}): type={}, message={}, causes={}&quot;, attempt, e.getClass().getName(), e.getMessage(), summarizeCauses(e));</b>
<b class="nc">&nbsp;                    throw new DataSyncException(buildErr(minDate, maxDate, &quot;unexpected failure (no retry)&quot;), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String summarizeCauses(Throwable t) {
<b class="nc">&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;        int depth = 0;</b>
<b class="nc">&nbsp;        while (t != null &amp;&amp; depth &lt; 8) { // limit depth</b>
<b class="nc">&nbsp;            sb.append(&#39;[&#39;).append(depth).append(&#39;:&#39;).append(t.getClass().getSimpleName()).append(&#39;:&#39;);</b>
<b class="nc">&nbsp;            String m = t.getMessage();</b>
<b class="nc">&nbsp;            if (m != null) sb.append(m, 0, Math.min(m.length(), 120));</b>
<b class="nc">&nbsp;            sb.append(&#39;]&#39;);</b>
<b class="nc">&nbsp;            t = t.getCause();</b>
<b class="nc">&nbsp;            depth++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean handleOrRetry(LocalDate minDate, LocalDate maxDate, int attempt, Throwable ex, List&lt;FactProduction&gt; records) {
<b class="nc">&nbsp;        boolean unique = isUniqueConstraintViolation(ex);</b>
<b class="nc">&nbsp;        if (unique) {</b>
<b class="nc">&nbsp;            syncCollisionCounter().increment();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!unique || attempt &gt;= retryMaxAttempts) {</b>
<b class="nc">&nbsp;            return false; // No se reintenta</b>
&nbsp;        }
&nbsp;        // Reset IDs to ensure fresh INSERTs next attempt (prevent stale entity state after rollback)
<b class="nc">&nbsp;        for (FactProduction fp : records) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (fp.getId() != null) fp.setId(null);</b>
&nbsp;            } catch (Exception ignore) { }
&nbsp;        }
<b class="nc">&nbsp;        long backoffMs = 200L * attempt;</b>
<b class="nc">&nbsp;        log.warn(&quot;Unique constraint collision (attempt {} of {}) for range {} to {}. Retrying after {} ms... (ids reset)&quot;, attempt, retryMaxAttempts, minDate, maxDate, backoffMs);</b>
<b class="nc">&nbsp;        sleepQuiet(backoffMs);</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void executeOnce(LocalDate minDate, LocalDate maxDate, List&lt;FactProduction&gt; records) {
<b class="nc">&nbsp;        long start = System.nanoTime();</b>
&nbsp;        try {
<b class="nc">&nbsp;            transactionTemplate.execute(status -&gt; {</b>
<b class="nc">&nbsp;                log.info(&quot;Starting data sync for date range {} to {} with {} records (lockEnabled={}, retryUnique={})&quot;, minDate, maxDate, records.size(), etlLockEnabled, retryUniqueEnabled);</b>
&nbsp;                // Diagnostic: log injection of test sleep values
<b class="nc">&nbsp;                log.debug(&quot;Diagnostic: lockTestSleepMs={} syncTestSleepMs={} (for tests)&quot;, lockTestSleepMs, syncTestSleepMs);</b>
&nbsp;
<b class="nc">&nbsp;                if (etlLockEnabled) {</b>
<b class="nc">&nbsp;                    tryAcquireAdvisoryLock(minDate, maxDate);</b>
<b class="nc">&nbsp;                    if (lockTestSleepMs &gt; 0) {</b>
<b class="nc">&nbsp;                        try { Thread.sleep(lockTestSleepMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                int deleted = factProductionRepository.deleteByFechaContabilizacionBetween(minDate, maxDate);</b>
<b class="nc">&nbsp;                rowsDeletedCounter().increment(deleted);</b>
<b class="nc">&nbsp;                if (syncTestSleepMs &gt; 0) { // Pausa de test para inducir colisiones concurrentes</b>
<b class="nc">&nbsp;                    try { Thread.sleep(syncTestSleepMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }</b>
&nbsp;                }
<b class="nc">&nbsp;                log.debug(&quot;Deleted {} existing rows in date range {} to {}&quot;, deleted, minDate, maxDate);</b>
<b class="nc">&nbsp;                if (!records.isEmpty()) {</b>
<b class="nc">&nbsp;                    factProductionRepository.saveAll(records);</b>
<b class="nc">&nbsp;                    factProductionRepository.flush();</b>
<b class="nc">&nbsp;                    rowsInsertedCounter().increment(records.size());</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        long days = java.time.Duration.between(minDate.atStartOfDay(), maxDate.plusDays(1).atStartOfDay()).toDays();</b>
<b class="nc">&nbsp;                        if (days &lt; 1) days = 1;</b>
<b class="nc">&nbsp;                        windowDaysSummary().record(days);</b>
<b class="nc">&nbsp;                        batchSizeSummary().record(records.size());</b>
&nbsp;                    } catch (Exception ignore) { }
<b class="nc">&nbsp;                    log.info(&quot;Successfully synced {} records for date range {} to {}&quot;, records.size(), minDate, maxDate);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.info(&quot;No records to sync for date range {} to {}&quot;, minDate, maxDate);</b>
&nbsp;                }
<b class="nc">&nbsp;                return null;</b>
&nbsp;            });
&nbsp;        } finally {
<b class="nc">&nbsp;            syncDurationTimer().record(Duration.ofNanos(System.nanoTime() - start));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void tryAcquireAdvisoryLock(LocalDate minDate, LocalDate maxDate) {
<b class="nc">&nbsp;        long lockKey = computeLockKey(minDate, maxDate);</b>
&nbsp;        try {
<b class="nc">&nbsp;            log.debug(&quot;Attempting to acquire advisory lock (key={}) for range {} to {}&quot;, lockKey, minDate, maxDate);</b>
<b class="nc">&nbsp;            Object res = entityManager.createNativeQuery(&quot;SELECT pg_advisory_xact_lock(?);&quot;)</b>
<b class="nc">&nbsp;                    .setParameter(1, lockKey)</b>
<b class="nc">&nbsp;                    .getSingleResult();</b>
<b class="nc">&nbsp;            log.debug(&quot;Acquired advisory lock key={} for range {} to {} (result={})&quot;, lockKey, minDate, maxDate, res);</b>
&nbsp;        } catch (RuntimeException ex) {
&nbsp;            // H2 u otras BDs no soportan la función; continuar sin lock
<b class="nc">&nbsp;            log.warn(&quot;Advisory lock skipped/failed for key={} (range {} to {}) - exception: {}: {}&quot;, lockKey, minDate, maxDate, ex.getClass().getName(), ex.getMessage());</b>
<b class="nc">&nbsp;            log.trace(&quot;Advisory lock exception stack: &quot;, ex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private long computeLockKey(LocalDate minDate, LocalDate maxDate) {
&nbsp;        // Combina epochDay para generar llave determinística en 64 bits.
<b class="nc">&nbsp;        long a = minDate != null ? minDate.toEpochDay() : 0L;</b>
<b class="nc">&nbsp;        long b = maxDate != null ? maxDate.toEpochDay() : 0L;</b>
<b class="nc">&nbsp;        return (a &lt;&lt; 32) ^ b;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isUniqueConstraintViolation(Throwable e) {
&nbsp;        // Diagnostic: log top-level exception class and message
<b class="nc">&nbsp;        if (e == null) return false;</b>
<b class="nc">&nbsp;        log.debug(&quot;Checking unique constraint violation for exception type: {} message: {}&quot;, e.getClass().getName(), e.getMessage());</b>
<b class="nc">&nbsp;        Throwable cur = e;</b>
<b class="nc">&nbsp;        while (cur != null) {</b>
<b class="nc">&nbsp;            String msg = cur.getMessage();</b>
<b class="nc">&nbsp;            if (msg != null) {</b>
<b class="nc">&nbsp;                String lower = msg.toLowerCase();</b>
<b class="nc">&nbsp;                if (lower.contains(&quot;uq_fact_prod_natural&quot;) || lower.contains(&quot;duplicate key&quot;) || lower.contains(&quot;unique constraint&quot;) || lower.contains(&quot;violates unique constraint&quot;)) {</b>
<b class="nc">&nbsp;                    log.debug(&quot;Detected unique violation by message on class {}&quot;, cur.getClass().getName());</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                if (cur.getClass().getName().equals(&quot;org.postgresql.util.PSQLException&quot;)) {</b>
<b class="nc">&nbsp;                    String sqlState = (String) cur.getClass().getMethod(&quot;getSQLState&quot;).invoke(cur);</b>
<b class="nc">&nbsp;                    log.debug(&quot;Postgres PSQLException SQLState={}&quot;, sqlState);</b>
<b class="nc">&nbsp;                    if (&quot;23505&quot;.equals(sqlState)) return true;</b>
&nbsp;                }
&nbsp;            } catch (Exception inv) {
<b class="nc">&nbsp;                log.trace(&quot;Could not read SQLState from exception {}: {}&quot;, cur.getClass().getName(), inv.getMessage());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cur instanceof java.sql.BatchUpdateException bue) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    String st = bue.getSQLState();</b>
<b class="nc">&nbsp;                    log.debug(&quot;BatchUpdateException SQLState={}&quot;, st);</b>
<b class="nc">&nbsp;                    if (&quot;23505&quot;.equals(st)) return true;</b>
<b class="nc">&nbsp;                    if (bue.getNextException() != null) {</b>
<b class="nc">&nbsp;                        String nextSt = bue.getNextException().getSQLState();</b>
<b class="nc">&nbsp;                        log.debug(&quot;BatchUpdateException nextException SQLState={}&quot;, nextSt);</b>
<b class="nc">&nbsp;                        if (&quot;23505&quot;.equals(nextSt)) return true;</b>
&nbsp;                    }
&nbsp;                } catch (Exception ignore) { }
&nbsp;            }
<b class="nc">&nbsp;            if (cur.getClass().getName().equals(&quot;org.hibernate.exception.ConstraintViolationException&quot;)) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    Object sqlEx = cur.getClass().getMethod(&quot;getSQLException&quot;).invoke(cur);</b>
<b class="nc">&nbsp;                    if (sqlEx instanceof java.sql.SQLException sql) {</b>
<b class="nc">&nbsp;                        String s = sql.getSQLState();</b>
<b class="nc">&nbsp;                        log.debug(&quot;Hibernate ConstraintViolationException SQLState={}&quot;, s);</b>
<b class="nc">&nbsp;                        if (&quot;23505&quot;.equals(s)) return true;</b>
&nbsp;                    }
&nbsp;                } catch (Exception ignore) { }
&nbsp;            }
<b class="nc">&nbsp;            cur = cur.getCause();</b>
&nbsp;        }
&nbsp;        // Fallback: scan stack trace text for SQLState 23505
&nbsp;        try {
<b class="nc">&nbsp;            java.io.StringWriter sw = new java.io.StringWriter();</b>
<b class="nc">&nbsp;            java.io.PrintWriter pw = new java.io.PrintWriter(sw);</b>
<b class="nc">&nbsp;            e.printStackTrace(pw);</b>
<b class="nc">&nbsp;            String stack = sw.toString();</b>
<b class="nc">&nbsp;            if (stack.contains(&quot;23505&quot;)) {</b>
<b class="nc">&nbsp;                log.debug(&quot;Detected SQLState 23505 in stack trace&quot;);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        } catch (Exception ignore) { }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sleepQuiet(long ms) {
<b class="nc">&nbsp;        try { Thread.sleep(ms); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }</b>
&nbsp;    }
&nbsp;
&nbsp;    private String buildErr(LocalDate minDate, LocalDate maxDate, String reason) {
<b class="nc">&nbsp;        return &quot;Failed to sync date range &quot; + minDate + &quot; to &quot; + maxDate + &quot; (&quot; + reason + &quot;)&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Custom exception for data synchronization failures
&nbsp;     */
&nbsp;    public static class DataSyncException extends RuntimeException {
<b class="nc">&nbsp;        public DataSyncException(String message, Throwable cause) { super(message, cause); }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-10-22 07:08</div>
</div>
</body>
</html>
