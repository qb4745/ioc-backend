


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > EtlProcessingService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.cambiaso.ioc.service</a>
</div>

<h1>Coverage Summary for Class: EtlProcessingService (com.cambiaso.ioc.service)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EtlProcessingService</td>
<td class="coverageStat">
  <span class="percent">
    11.8%
  </span>
  <span class="absValue">
    (2/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.5%
  </span>
  <span class="absValue">
    (7/127)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EtlProcessingService$$SpringCGLIB$$0</td>
  </tr>
  <tr>
    <td class="name">EtlProcessingService$DateRange</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EtlProcessingService$ParsedFileData</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    10.5%
  </span>
  <span class="absValue">
    (2/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.4%
  </span>
  <span class="absValue">
    (7/129)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.cambiaso.ioc.service;
&nbsp;
&nbsp;import com.cambiaso.ioc.dto.NotificationPayload;
&nbsp;import com.cambiaso.ioc.exception.FileValidationException;
&nbsp;import com.cambiaso.ioc.exception.JobConflictException;
&nbsp;import com.cambiaso.ioc.persistence.entity.FactProduction;
&nbsp;import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
&nbsp;import io.micrometer.core.annotation.Timed;
&nbsp;import io.micrometer.core.instrument.Counter;
&nbsp;import io.micrometer.core.instrument.DistributionSummary;
&nbsp;import io.micrometer.core.instrument.MeterRegistry;
&nbsp;import io.micrometer.core.instrument.Timer;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.slf4j.MDC;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.scheduling.annotation.Async;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.web.multipart.MultipartFile;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.security.MessageDigest;
&nbsp;import java.security.NoSuchAlgorithmException;
&nbsp;import java.time.LocalDate;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.UUID;
&nbsp;
<b class="fc">&nbsp;@Slf4j</b>
&nbsp;@Service
&nbsp;public class EtlProcessingService {
&nbsp;
&nbsp;    private final EtlJobService etlJobService;
&nbsp;    private final NotificationService notificationService;
&nbsp;    private final DataSyncService dataSyncService;
&nbsp;    private final ParserService parserService;
&nbsp;    private final MeterRegistry meterRegistry;
&nbsp;
&nbsp;    // Single constructor for autowiring with optional MeterRegistry
&nbsp;    public EtlProcessingService(EtlJobService etlJobService,
&nbsp;                               NotificationService notificationService,
&nbsp;                               DataSyncService dataSyncService,
&nbsp;                               ParserService parserService,
<b class="fc">&nbsp;                               @Autowired(required = false) MeterRegistry meterRegistry) {</b>
<b class="fc">&nbsp;        this.etlJobService = etlJobService;</b>
<b class="fc">&nbsp;        this.notificationService = notificationService;</b>
<b class="fc">&nbsp;        this.dataSyncService = dataSyncService;</b>
<b class="fc">&nbsp;        this.parserService = parserService;</b>
<b class="fc">&nbsp;        this.meterRegistry = meterRegistry;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Async(&quot;etlExecutor&quot;)
&nbsp;    public void processFile(MultipartFile file, String userId, UUID jobId) {
<b class="nc">&nbsp;        log.info(&quot;Starting ETL process for job ID: {}&quot;, jobId);</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (file == null || file.isEmpty()) {</b>
<b class="nc">&nbsp;                throw new FileValidationException(&quot;Uploaded file is null or empty.&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // 1. Parse file and extract records
<b class="nc">&nbsp;            log.debug(&quot;Job {}: Parsing file content.&quot;, jobId);</b>
<b class="nc">&nbsp;            notificationService.notifyUser(userId, jobId, new NotificationPayload(&quot;PROCESANDO&quot;, &quot;Parsing file content.&quot;));</b>
<b class="nc">&nbsp;            List&lt;FactProduction&gt; parsedRecords = parserService.parse(file.getInputStream());</b>
&nbsp;
<b class="nc">&nbsp;            if (parsedRecords.isEmpty()) {</b>
<b class="nc">&nbsp;                log.warn(&quot;Job {}: File is empty or contains no valid data rows. Finishing as success.&quot;, jobId);</b>
<b class="nc">&nbsp;                etlJobService.updateJobStatus(jobId, &quot;EXITO&quot;, &quot;File processed successfully: No data rows found to sync.&quot;);</b>
<b class="nc">&nbsp;                notificationService.notifyUser(userId, jobId, new NotificationPayload(&quot;EXITO&quot;, &quot;File processed, no data rows found.&quot;));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            // 2. Calculate date range from parsed data
<b class="nc">&nbsp;            LocalDate minDate = parsedRecords.stream()</b>
<b class="nc">&nbsp;                    .map(FactProduction::getFechaContabilizacion)</b>
<b class="nc">&nbsp;                    .min(LocalDate::compareTo)</b>
<b class="nc">&nbsp;                    .orElseThrow(() -&gt; new FileValidationException(&quot;Could not determine minimum date from file.&quot;));</b>
&nbsp;
<b class="nc">&nbsp;            LocalDate maxDate = parsedRecords.stream()</b>
<b class="nc">&nbsp;                    .map(FactProduction::getFechaContabilizacion)</b>
<b class="nc">&nbsp;                    .max(LocalDate::compareTo)</b>
<b class="nc">&nbsp;                    .orElseThrow(() -&gt; new FileValidationException(&quot;Could not determine maximum date from file.&quot;));</b>
&nbsp;
&nbsp;            // Validación defensiva: todas las fechas deben estar dentro del rango calculado
<b class="nc">&nbsp;            boolean outOfRange = parsedRecords.stream().anyMatch(r -&gt; r.getFechaContabilizacion().isBefore(minDate) || r.getFechaContabilizacion().isAfter(maxDate));</b>
<b class="nc">&nbsp;            if (outOfRange) {</b>
<b class="nc">&nbsp;                throw new FileValidationException(&quot;Parsed records contain dates outside inferred range: &quot; + minDate + &quot; to &quot; + maxDate);</b>
&nbsp;            }
&nbsp;
&nbsp;            // 3. Update job with date range and check for conflicts
<b class="nc">&nbsp;            log.debug(&quot;Job {}: Checking for window lock for date range {} to {}.&quot;, jobId, minDate, maxDate);</b>
<b class="nc">&nbsp;            etlJobService.updateJobDateRange(jobId, minDate, maxDate);</b>
&nbsp;
<b class="nc">&nbsp;            if (etlJobService.isWindowLocked(jobId, minDate, maxDate)) {</b>
&nbsp;                // Métrica de conflicto de ventana
<b class="nc">&nbsp;                if (meterRegistry != null) {</b>
<b class="nc">&nbsp;                    Counter.builder(&quot;etl.window.conflicts&quot;).register(meterRegistry).increment();</b>
&nbsp;                }
<b class="nc">&nbsp;                throw new JobConflictException(&quot;Another ETL job is processing this date range.&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // 4. Sync data to database
<b class="nc">&nbsp;            log.debug(&quot;Job {}: Synchronizing {} records to the database.&quot;, jobId, parsedRecords.size());</b>
<b class="nc">&nbsp;            notificationService.notifyUser(userId, jobId, new NotificationPayload(&quot;SINCRONIZANDO&quot;, &quot;Writing data to database.&quot;));</b>
<b class="nc">&nbsp;            dataSyncService.syncWithDeleteInsert(minDate, maxDate, parsedRecords);</b>
&nbsp;
&nbsp;            // 5. Finalize job
<b class="nc">&nbsp;            String successDetails = String.format(&quot;ETL process completed successfully. Synced %d records.&quot;, parsedRecords.size());</b>
<b class="nc">&nbsp;            log.info(&quot;Job {} completed successfully.&quot;, jobId);</b>
<b class="nc">&nbsp;            etlJobService.updateJobStatus(jobId, &quot;EXITO&quot;, successDetails);</b>
<b class="nc">&nbsp;            notificationService.notifyUser(userId, jobId, new NotificationPayload(&quot;EXITO&quot;, &quot;Process finished.&quot;));</b>
&nbsp;
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;ETL process failed for job ID: {}&quot;, jobId, e);</b>
<b class="nc">&nbsp;            String errorMessage = e.getMessage();</b>
<b class="nc">&nbsp;            etlJobService.updateJobStatus(jobId, &quot;FALLO&quot;, errorMessage);</b>
<b class="nc">&nbsp;            notificationService.notifyUser(userId, jobId, new NotificationPayload(&quot;FALLO&quot;, errorMessage));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @CircuitBreaker(name = &quot;notification-service&quot;, fallbackMethod = &quot;fallbackNotifyUser&quot;)
&nbsp;    private void notifyUserWithCircuitBreaker(String userId, UUID jobId, NotificationPayload payload) {
<b class="nc">&nbsp;        notificationService.notifyUser(userId, jobId, payload);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Now actually used by Circuit Breaker (parameters now used properly)
&nbsp;    @SuppressWarnings(&quot;unused&quot;) // Used by Circuit Breaker annotation
&nbsp;    private void fallbackNotifyUser(String userId, UUID jobId, NotificationPayload payload, Exception ex) {
<b class="nc">&nbsp;        log.warn(&quot;Notification service unavailable for job {} (user: {}), message: {}. Reason: {}&quot;,</b>
<b class="nc">&nbsp;                jobId, userId, payload.getMessage(), ex.getMessage());</b>
&nbsp;
&nbsp;        // Store notification for later retry or use alternative notification method
<b class="nc">&nbsp;        recordNotificationFallback(ex);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Timed(value = &quot;etl.file.hash.calculation&quot;, description = &quot;Time taken to calculate file hash&quot;)
&nbsp;    public String calculateFileHash(MultipartFile file) {
&nbsp;        try {
<b class="nc">&nbsp;            MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</b>
<b class="nc">&nbsp;            byte[] hash = digest.digest(file.getBytes());</b>
<b class="nc">&nbsp;            StringBuilder hexString = new StringBuilder();</b>
<b class="nc">&nbsp;            for (byte b : hash) {</b>
<b class="nc">&nbsp;                String hex = Integer.toHexString(0xff &amp; b);</b>
<b class="nc">&nbsp;                if (hex.length() == 1) hexString.append(&#39;0&#39;);</b>
<b class="nc">&nbsp;                hexString.append(hex);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            recordFileMetrics(file);</b>
<b class="nc">&nbsp;            return hexString.toString();</b>
&nbsp;
&nbsp;        } catch (NoSuchAlgorithmException | IOException e) {
<b class="nc">&nbsp;            recordHashError(e);</b>
<b class="nc">&nbsp;            throw new FileValidationException(&quot;Could not calculate file hash: &quot; + e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Helper methods to improve code organization and readability
&nbsp;
&nbsp;    private void validateFile(MultipartFile file) {
<b class="nc">&nbsp;        if (file == null || file.isEmpty()) {</b>
<b class="nc">&nbsp;            throw new FileValidationException(&quot;Uploaded file is null or empty.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Additional validations
<b class="nc">&nbsp;        if (file.getSize() &gt; 50 * 1024 * 1024) { // 50MB limit</b>
<b class="nc">&nbsp;            throw new FileValidationException(&quot;File size exceeds maximum allowed size of 50MB.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ParsedFileData parseFileForData(MultipartFile file) {
&nbsp;        // In real implementation, this would parse the actual file content
&nbsp;        // For now, simulate with default dates and basic file analysis
&nbsp;        try {
&nbsp;            // Actually use the file parameter to extract some basic info
<b class="nc">&nbsp;            String filename = file.getOriginalFilename();</b>
<b class="nc">&nbsp;            long fileSize = file.getSize();</b>
&nbsp;
<b class="nc">&nbsp;            log.debug(&quot;Parsing file: {} (size: {} bytes)&quot;, filename, fileSize);</b>
&nbsp;
<b class="nc">&nbsp;            Thread.sleep(500); // Simulate parsing time</b>
&nbsp;
&nbsp;            // Generate date range based on file characteristics (placeholder logic)
<b class="nc">&nbsp;            LocalDate startDate = LocalDate.of(2025, 1, 1);</b>
<b class="nc">&nbsp;            LocalDate endDate = LocalDate.of(2025, 1, 31);</b>
&nbsp;
&nbsp;
&nbsp;
<b class="nc">&nbsp;            DateRange dateRange = new DateRange(startDate, endDate);</b>
<b class="nc">&nbsp;            List&lt;FactProduction&gt; records = new ArrayList&lt;&gt;(); // Parse actual records from file content</b>
&nbsp;
<b class="nc">&nbsp;            return new ParsedFileData(dateRange, records);</b>
&nbsp;        } catch (InterruptedException e) {
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;            throw new FileValidationException(&quot;File parsing was interrupted&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Timer.Sample startTimer() {
<b class="nc">&nbsp;        return (meterRegistry != null) ? Timer.start(meterRegistry) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void recordSuccessMetrics(Timer.Sample sample) {
<b class="nc">&nbsp;        if (meterRegistry == null) return;</b>
&nbsp;
<b class="nc">&nbsp;        if (sample != null) {</b>
<b class="nc">&nbsp;            sample.stop(Timer.builder(&quot;etl.processing.duration&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;status&quot;, &quot;success&quot;)</b>
<b class="nc">&nbsp;                    .register(meterRegistry));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Counter.builder(&quot;etl.jobs.completed&quot;)</b>
<b class="nc">&nbsp;                .tag(&quot;status&quot;, &quot;success&quot;)</b>
<b class="nc">&nbsp;                .register(meterRegistry)</b>
<b class="nc">&nbsp;                .increment();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleProcessingError(UUID jobId, String userId, Exception e, Timer.Sample sample) {
<b class="nc">&nbsp;        String errorMessage = e.getMessage();</b>
<b class="nc">&nbsp;        etlJobService.updateJobStatus(jobId, &quot;FALLO&quot;, errorMessage);</b>
<b class="nc">&nbsp;        notifyUserWithCircuitBreaker(userId, jobId, new NotificationPayload(&quot;FALLO&quot;, errorMessage));</b>
<b class="nc">&nbsp;        recordFailureMetrics(sample, e);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void recordFailureMetrics(Timer.Sample sample, Exception e) {
<b class="nc">&nbsp;        if (meterRegistry == null) return;</b>
&nbsp;
<b class="nc">&nbsp;        if (sample != null) {</b>
<b class="nc">&nbsp;            sample.stop(Timer.builder(&quot;etl.processing.duration&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;status&quot;, &quot;failure&quot;)</b>
<b class="nc">&nbsp;                    .register(meterRegistry));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Counter.builder(&quot;etl.jobs.completed&quot;)</b>
<b class="nc">&nbsp;                .tag(&quot;status&quot;, &quot;failure&quot;)</b>
<b class="nc">&nbsp;                .tag(&quot;error_type&quot;, e.getClass().getSimpleName())</b>
<b class="nc">&nbsp;                .register(meterRegistry)</b>
<b class="nc">&nbsp;                .increment();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void recordNotificationFallback(Exception ex) {
<b class="nc">&nbsp;        if (meterRegistry != null) {</b>
<b class="nc">&nbsp;            Counter.builder(&quot;etl.notifications.fallback&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;reason&quot;, &quot;circuit_breaker_open&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;error_type&quot;, ex.getClass().getSimpleName())</b>
<b class="nc">&nbsp;                    .register(meterRegistry)</b>
<b class="nc">&nbsp;                    .increment();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private DistributionSummary fileSizeDist() {
<b class="nc">&nbsp;        if (meterRegistry == null) return null;</b>
<b class="nc">&nbsp;        return DistributionSummary.builder(&quot;etl.file.size.bytes&quot;)</b>
<b class="nc">&nbsp;                .baseUnit(&quot;bytes&quot;)</b>
<b class="nc">&nbsp;                .publishPercentileHistogram()</b>
<b class="nc">&nbsp;                .publishPercentiles(0.5,0.9,0.99)</b>
<b class="nc">&nbsp;                .register(meterRegistry);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void recordFileMetrics(MultipartFile file) {
<b class="nc">&nbsp;        if (meterRegistry != null) {</b>
<b class="nc">&nbsp;            meterRegistry.summary(&quot;etl.file.size&quot;).record(file.getSize());</b>
<b class="nc">&nbsp;            DistributionSummary ds = fileSizeDist();</b>
<b class="nc">&nbsp;            if (ds != null) ds.record(file.getSize());</b>
<b class="nc">&nbsp;            Counter.builder(&quot;etl.files.processed&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;type&quot;, getFileExtension(file.getOriginalFilename()))</b>
<b class="nc">&nbsp;                    .register(meterRegistry)</b>
<b class="nc">&nbsp;                    .increment();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void recordHashError(Exception e) {
<b class="nc">&nbsp;        if (meterRegistry != null) {</b>
<b class="nc">&nbsp;            Counter.builder(&quot;etl.file.hash.errors&quot;)</b>
<b class="nc">&nbsp;                    .tag(&quot;error_type&quot;, e.getClass().getSimpleName())</b>
<b class="nc">&nbsp;                    .register(meterRegistry)</b>
<b class="nc">&nbsp;                    .increment();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getFileExtension(String filename) {
<b class="nc">&nbsp;        if (filename == null || !filename.contains(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;            return &quot;unknown&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toLowerCase();</b>
&nbsp;    }
&nbsp;
&nbsp;    // Record classes for better type safety
<b class="nc">&nbsp;    private record DateRange(LocalDate minDate, LocalDate maxDate) {}</b>
<b class="nc">&nbsp;    private record ParsedFileData(DateRange dateRange, List&lt;FactProduction&gt; records) {}</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-10-22 07:08</div>
</div>
</body>
</html>
